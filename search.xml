<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[💐Spring学习-Bean的IoC&DI]]></title>
    <url>%2F2019%2F03%2F05%2FSpring%E5%AD%A6%E4%B9%A0-Bean%E7%9A%84IoC-DI%2F</url>
    <content type="text"><![CDATA[主要来说明Denpendeny Injection 和 IoC以及他们之间的关系。 Spring IoC发展史☝ 直接交互 Student stu = new Student(); stu.setXxx(); ✌ 简单工厂 👌 IoC （超级工厂） 🔍关于IoC和DI两个概念个人通过查找所总结的Martin Fowler将IoC改名为DI的说法。Martin Flower的Inversion of Control and the Dependency Injection Pattern的原文 As a result I think we need a more specific name for this pattern. Inversion of Control is too generic a term, and thus peopel find it confusing. As a result with a lot of discussion with various IoC advocates we settled on the name Dependency Injection. 意思主要是：IoC作为一个模式描述过于宽泛（模糊）从而决定选择一个更为确切的名字DI来描述Spring中的IoC模式（DI还是在IoC的范畴里的） 另一种描述： Ioc ioc = new IoC(); DI di = (DI)ioc; 控制反转（浅层次） 控制： 对 对象的【创建、维护、销毁等生命周期的控制】 一般这个过程是由我们的程序去主动控制的，如果使用new关键字去创建对象，此过程中保持引用（维护），在失去全部引用后由GC去回收对象（销毁）。 反转： 将控制权【对象的创建、维护、销毁等】交由容器控制（需要时直接去容器中取出）- 拿来主义 依赖注入（深层次） 在传统应用中一个业务逻辑由多个对象共同协作，其中一个对象往往要依赖于其他对象共同完成因此就必须持有另一个对象的引用，往往通过new来实现其结果在于会导致高耦合和难以测试的代码。 谁依赖谁： 当然是某个容器管理对象依赖于 IoC 容器；“被注入对象的对象”依赖于“依赖对象”； 在传统应用中依赖：一个对象A的成员变量持有者另一个对象B的应用即A依赖于B。 为什么需要依赖 ： 容器管理对象需要 IoC 容器来提供对象需要的外部资源； IoC机制既然确定了控制权给了容器因此依赖关系也必须由IoC容器负责。负责的方式 —&gt; DI. 谁注入谁 ： IoC 容器注入某个对象，也就是注入“依赖对象”； 通过将依赖关系写入配置文件，然后在创建依赖关系的对象时，由IoC容器注入到依赖对象的对象。eg：在创建A时检查到存在A依赖于其他Bean，这种依赖关系通过IoC容器将A所以来的对象B创建后注入到A中（组转，通过反射机制实现） 为什么需要注入 ： 就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。 Spring IoC容器的原理 IoC容器就是一个超级工厂，它用来管理我们所有对象以及依赖关系 原理： 通过Java的反射机制实现的，通过反射我们所有对象以及依赖关系。在通过配置文件（xml）或者注解来描述类与类之间的关系。 即通过配置信息和反射技术来构建出对应的对象和依赖关系。 根据Bean配置信息在容器内部创建Bean定义注册表 根据注册表加载、实例化bean、建立Bean与Bean之间的依赖关系 将这些准备就绪的Bean放到Map缓存池中，等待应用程序调用 Spring IoC的好处 不用自己组装，拿来就用。 享受单例的好处，效率高，不浪费空间。 便于单元测试，方便切换mock组件。 便于进行AOP操作，对于使用者是透明的。 统一配置，便于修改。 – 知乎@Intopass的回答 Ioc主要的实现方式有2种：依赖查找、依赖注入（更可取）。 对于对象本身：拿来主义 对于容器本身：好莱坞原则(Don’t call us, we’ll call you!) 框架提供了骨架，你只要提供肉就可以了，你的肉在骨架中被调用。 框架提供了骨架（通用代码），你提供肉（业务逻辑）就行了。 参考文章： Spring IoC有什么好处？ 浅谈我对Spring IoC与DI理解 Spring IoC容器 - 实验楼]]></content>
      <categories>
        <category>Spring-Learning</category>
      </categories>
      <tags>
        <tag>IoC&amp;DI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[💐Spring学习-核心容器]]></title>
    <url>%2F2019%2F03%2F05%2FSpring%E5%AD%A6%E4%B9%A0-%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在基于Spring的应用中，Spring Container负责创建对象、装配他们并管理他们整个声明周期。 Spring容器主要有两种类型（Bean工厂和应用上下文）🏭 Bean工厂（org.springframework.beans.factory.beanFactory） 管理Bean工厂用于初始化各种Bean，并调用他们的声明周期 BeanFactory beanFactory = new XmlBeanFactory(new FileSystemResource(“F://applicationContext.xml”)); 🏭 应用上下文(初始化时自检（org.springframework.context.ApplicationContext） ApplicationContext基于BeanFactory构建是其一个子接口。提供应用框架级别的服务，eg：资源访问、事件传播、国际化… 常用的几种应用上下文1 . 🐷通过ClassPathXmlApplicationContext创建 ClassPathXmlApplicationContext从类路径classPath中寻找指定的xml配置文件 ApplicationContext ac = new ClassPathXmlApplicationContext(“beans.xml”); 2 . 🐷通过FileSystemXmlApplicationContext创建 FileSystemXmlApplicationContext从文件系统下的一个或多个xml配置文件中加载上下文 FileSystemXmlApplicationContext ac = new FileSystemXmlApplicationContext(“c:/knight.xml”) 从容器中获取所创建的Bean Object getBean(String name) 根据容器中的Bean的id或name来获取指定的Bena，获取之后需要强制类型转换 getBean(Class requiredType) 根据类的类型来获取Bean的实例，此方法为泛型方法不需要强制类型转换。]]></content>
      <categories>
        <category>Spring-Learning</category>
      </categories>
      <tags>
        <tag>Spring核心容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统的唯一id生成算法]]></title>
    <url>%2F2019%2F03%2F04%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%94%AF%E4%B8%80id%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[设想开发一个订单系统，每此订单都会作为一次记录，记录在数据库中当然订单会根据类型的不同分布在几种不同的表中以自增的id作为主键，但如果有一个业务统一记录所有的订单记录，则会出现相同的订单id。面对这种问题就会想到每一次订单都让系统产生一个独立于数据库的唯一主键，唯一是在整个分布式系统之中就全局而言的，然后插入各个表中，保证每个表内的唯一标识id是全局唯一的。 方法一： 数据库自动生成id此种做法依据数据库本身的特性设置一个自增组件在面对单一简单的业务时插入信息没有太多压力但面对高并发的情况下就明显不能够解决此种问题。 方法二：UUID 通用唯一识别码（Universally Unique Identifier）好处 全局唯一，依赖每个系统本地生成不用基于数据库 坏处 UUID是无序的，但又是系统想要生成的id是粗略有序 UUID比较长，占用空间大，会影响性能 生成的ID很随机，不是人能读懂的 索引效率低 Java生成UUID import java.util.UUID; public class Test2 { public String getUid() { UUID uid = UUID.randomUUID(); return uid.toString().replace(&quot;-&quot;, &quot;&quot;); } public static void main(String[] args) { for(int i = 0 ; i &lt; 32; i ++) { System.out.println(new Test2().getUid()); } } } 方案三： 根据实际业务和多种随机数共同组件（eg：系统当前时间） 如果只用系统时间作为唯一id，在并发很高的时候，eg：1秒并发几千，会有重复的情况。 可以将业务字段值 + 当前时间拼接起来，组成一个全局的唯一的编号，例如订单编号：时间戳 + 用户id + 业务含义编码 方法四：snowflake算法 snowflake算法，是twitter开源的分布式id生成算法. 核心思想：使用一个64bit的long型数字作为全局唯一id，在这64个bit中，其中1个bit是不用的，然后用其他的41比特作为毫秒数，用10bit作为工作机器id，12bit作为序列号。 0 | 0001100 10100010 10111110 10001001 01011100 00 |1001|1 1001|0000 00000000| 上面第一个部分，是1个bit：0，这个是无意义的 上面第二个部分是41个bit：表示的是时间戳 上面第三个部分是5个bit：表示的是机房id，10001 上面第四个部分是5个bit：表示的是机器id，1 1001 上面第五个部分是12个bit：表示的序号，就是某个机房某台机器上这一毫秒内同时生成的id的序号，0000 00000000 这个算法可以保证说，一个机房的一台机器上，在同一毫秒内，生成了一个唯一的id。可能一个毫秒内会生成多个id，但是有最后12个bit的序号来区分开来。 snowflake算法的代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class IdWorker &#123; private long workerId; // 这个就是代表了机器id private long datacenterId; // 这个就是代表了机房id private long sequence; // 这个就是代表了一毫秒内生成的多个id的最新序号 public IdWorker(long workerId, long datacenterId, long sequence) &#123; // sanity check for workerId // 这儿不就检查了一下，要求就是你传递进来的机房id和机器id不能超过32，不能小于0 if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123; throw new IllegalArgumentException( String.format(&quot;worker Id can&apos;t be greater than %d or less than 0&quot;,maxWorkerId)); &#125; if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) &#123; throw new IllegalArgumentException( String.format(&quot;datacenter Id can&apos;t be greater than %d or less than 0&quot;,maxDatacenterId)); &#125; this.workerId = workerId; this.datacenterId = datacenterId; this.sequence = sequence; &#125; private long twepoch = 1288834974657L; private long workerIdBits = 5L; private long datacenterIdBits = 5L; // 这个是二进制运算，就是5 bit最多只能有31个数字，也就是说机器id最多只能是32以内 private long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); // 这个是一个意思，就是5 bit最多只能有31个数字，机房id最多只能是32以内 private long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); private long sequenceBits = 12L; private long workerIdShift = sequenceBits; private long datacenterIdShift = sequenceBits + workerIdBits; private long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; private long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); private long lastTimestamp = -1L; public long getWorkerId()&#123; return workerId; &#125; public long getDatacenterId() &#123; return datacenterId; &#125; public long getTimestamp() &#123; return System.currentTimeMillis(); &#125; // 这个是核心方法，通过调用nextId()方法，让当前这台机器上的snowflake算法程序生成一个全局唯一的id public synchronized long nextId() &#123; // 这儿就是获取当前时间戳，单位是毫秒 long timestamp = timeGen(); if (timestamp &lt; lastTimestamp) &#123; System.err.printf( &quot;clock is moving backwards. Rejecting requests until %d.&quot;, lastTimestamp); throw new RuntimeException( String.format(&quot;Clock moved backwards. Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp)); &#125; // 下面是说假设在同一个毫秒内，又发送了一个请求生成一个id // 这个时候就得把seqence序号给递增1，最多就是4096 if (lastTimestamp == timestamp) &#123; // 这个意思是说一个毫秒内最多只能有4096个数字，无论你传递多少进来， //这个位运算保证始终就是在4096这个范围内，避免你自己传递个sequence超过了4096这个范围 sequence = (sequence + 1) &amp; sequenceMask; if (sequence == 0) &#123; timestamp = tilNextMillis(lastTimestamp); &#125; &#125; else &#123; sequence = 0; &#125; // 这儿记录一下最近一次生成id的时间戳，单位是毫秒 lastTimestamp = timestamp; // 这儿就是最核心的二进制位运算操作，生成一个64bit的id // 先将当前时间戳左移，放到41 bit那儿；将机房id左移放到5 bit那儿；将机器id左移放到5 bit那儿；将序号放最后12 bit // 最后拼接起来成一个64 bit的二进制数字，转换成10进制就是个long型 return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift) | (workerId &lt;&lt; workerIdShift) | sequence; &#125; private long tilNextMillis(long lastTimestamp) &#123; long timestamp = timeGen(); while (timestamp &lt;= lastTimestamp) &#123; timestamp = timeGen(); &#125; return timestamp; &#125; private long timeGen()&#123; return System.currentTimeMillis(); &#125; //---------------测试--------------- public static void main(String[] args) &#123; IdWorker worker = new IdWorker(1,1,1); for (int i = 0; i &lt; 30; i++) &#123; System.out.println(worker.nextId()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java生成唯一id</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[💐The Spring Framework itself]]></title>
    <url>%2F2019%2F03%2F03%2F%E4%BB%80%E4%B9%88%E6%98%AFSpring%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[Spring的主要目的： 开发者： Rod Johnson 时间： 2003年 描述：一个分层的JavaSE/EE full-stack（一站式）轻量级开源框架 ====&gt; 🎖用来替代更加重量级的企业级Java技术从而简化Java开发（eg：EJB） 相对于EJB来说，Spring提供了更加轻量级和简单的编程模型，它在非侵入的前提下对POJO类增强功能。 💨简化Java开发 ★★★Spring为了全方位的简化企业级Java开发的4中关键策略： 基于POJO轻量级和非侵入式编程 基于依赖注入（DI/IoC）和面向接口 —&gt; 松耦合 基于切面（AOP）和惯例 —&gt; 声明式编程 通过切面和模板 —&gt; 减少样板式代码 👨‍💻Spring架构 Core Container：Beans、Core、Context、Expression Language Module Name Desc Beans 框架的基础部分提供的BeanFactory是容器核心，是工厂模式的典型实现，所有Bean依赖关系由它维护 Core 封装框架依赖的最底层部分，包括DI和IoC功能 Context 以Beans和Core为基础，集成Bean模块功能并添加资源绑定、数据验证、国际化、容器声明周期等。核心接口：ApplicationContext EL 是运行时查询和操作对象图的强大语言 ⚒Spring开发所需要的最基本的jar（5+1） spring-aop.jar : 开发AOP特性需要的jar spring-beans.jar : 处理Bean的jar spring-core.jar : spring核心jar spring-context.jar : 处理Spring上下文的jar spring-expression.jar : Spring表达式第三方提供的日志 commons-logging.jar : 日志 📜学习清单(Learning-List)一 ： Spring概述 1.1 什么是Spring 1.2 Spring的核心容器（BeanFactory和ApplicationContext） 1.3 Spring的依赖注入 二 ： Spring中的Bean 2.1 Bean的配置 2.2 Bean的实例化（3种） 2.3 Bean的作用域（主要的2种） 2.4 Bean的声明周期 2.5 Bean的装配方式（各种数据类型的装配） 三 ： Spring AOP 3.1 Spring AOP简介（是什么以及相关术语） 3.2 动态代理（JDK动态代理&amp;CGLIB代理） 3.3 AOP实现代理 3.4 AspectJ开发（基于XML和注解的两种方式） 四 ： Spring 数据库开发 4.1 Spring JDBC（JdbcTemplate和JDBC的配置） 4.2 Spring JdbcTemplate常用的方法 execute() update() query()]]></content>
      <categories>
        <category>Spring-Learning</category>
      </categories>
      <tags>
        <tag>Spring基础扫盲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring关键字之自动扫描（Annotation）和自动装配]]></title>
    <url>%2F2019%2F03%2F02%2FSpring%E5%85%B3%E9%94%AE%E5%AD%97%E4%B9%8B%E8%87%AA%E5%8A%A8%E6%89%AB%E6%8F%8F%E5%92%8C%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%2F</url>
    <content type="text"><![CDATA[自动扫描组件 通常在xml配置文件中，声明一个bean或者component，然后Spring容器会检查和注册你的bean或component。实际上,Spring支持自动扫描bean或者component，可以不必在xml文件中繁琐的声明bean，Spring会自动扫描、检查指定的包的bean或component。 常见的自动扫描组件的注释类型（Annotation） Name DESC @Component 描述组件（泛化）中的bean，仅仅表示一个组件（Bean）,并且可以作用在任何层次，自动扫描component @Repository 数据访问层的bean（持久化层DAO），功能和component作用相同 @Service 作用在业务层（Service 层），功能和component作用相同 @Controller 作用在控制层（eg：SpringMVC中的controller），用于将控制层的类标识为Spring中的bean，其功能和component作用相同 @Autowired 用于对Bean的属性变量、属性的setter方法以及构造方法进行标注，配合注解处理器完成Bean的自动配置工作。 @Resource 作用和@Autowired一样，不过是按照组件的名称进行装配而@Autowired是按照组件的类型进行装配 @Qualifier 与@Autowired注解配合使用，会将默认的Bean类型装配修改为按Bean的实例名称装配，Bean的实例名称由@Qualifier注解的参数指定。 实际上，@Repository、@Service、@Controller和@Component的作用一样都是将某个Class标识为Spring中的bean，但是为了提高代码的可读性、清晰性会对照使用 通过注解装配 CustomerDao.java @Component /* * @Component 表示当前Class是一个自动扫描组件。 * */ public class CustomerDAO { @Override public String toString(){ return &quot;hello, This is CustomerDAO&quot;; } } CustomerService.java 依赖于CustomerDao @Component public class CustomerService { @Autowired CustomerDAO customerDAO; public void setCustomerDAO(CustomerDAO customerDAO){ this.customerDAO = customerDAO; } @Override public String toString(){ return &quot;CustomerService[customerDAO= &quot; + customerDAO + &quot;]&quot;; } } 配置文件.xml /************🎖最原始的********************************/ &lt;bean id=&quot;customerService&quot; class=&quot;com.shiyanlou.spring.services.CustomerService&quot;&gt; &lt;property name=&quot;customerDAO&quot; ref=&quot;customerDAO&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;customerDAO&quot; class=&quot;com.shiyanlou.spring.dao.CustomerDAO&quot;/&gt; /************🎖通过注解********************************/ &lt;!-- 第一步开启注解管理器 --&gt; &lt;context:annotation-config/&gt; &lt;!-- 第一种❀： 依然是手动创建并装配相关对象--&gt; &lt;bean id=&quot;customerDao&quot; class=&quot;com.shiyanlou.spring.dao.CustomerDAO&quot;/&gt; &lt;bean id=&quot;customerService&quot; class=&quot;com.shiyanlou.spring.services.CustomerService&quot;/&gt; &lt;!-- 第二种❀： 通过组件扫描器进行装配--&gt; &lt;context:component-scan base-package=&quot;com.shiyanlou.spring&quot;/&gt; 自动装配Spring还提供了自动装配的功能，能够非常简化我们的配置 自动装配默认是打不开的，自动装配可以分为两种： 根据名字 —&gt; 装配 根据类型 —&gt; 装配 XML配置根据名字 &lt;bean id=&quot;userDao&quot; class=&quot;UserDao&quot;/&gt; &lt;!-- 1.通过名字来自动装配 2.发现userService中有个叫userDao的属性 3.看看IOC容器中没有叫userDao的对象 4.如果有，就装配进去 --&gt; &lt;bean id=&quot;userService&quot; class=&quot;UserService&quot; autowire=&quot;byName&quot;/&gt; XML配置根据注解 &lt;bean id=&quot;userDao&quot; class=&quot;UserDao&quot;/&gt; &lt;!-- 1.通过名字来自动装配 2.发现userService中有个叫userDao的属性 3.看看IOC容器UserDao类型的对象 4.如果有，就装配进去 --&gt; &lt;bean id=&quot;userService&quot; class=&quot;UserService&quot; autowire=&quot;byType&quot;/&gt;]]></content>
      <categories>
        <category>Spring-Learning</category>
      </categories>
      <tags>
        <tag>Spring注解和自动装配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Collections-集合类型的Bean]]></title>
    <url>%2F2019%2F03%2F02%2FSpring-Collections-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84Bean%2F</url>
    <content type="text"><![CDATA[怎样将值注入集合类型，包含以下四种主要的结合类型： List Set Map Properties List &lt;!-- java.util.List --&gt; &lt;!-- List属性注入： |- 字符串 -&gt; &lt;value&gt;xxx&lt;/value&gt; |- Bean -&gt; ref --&gt; &lt;property name=&quot;lists&quot;&gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;ref bean=&quot;personBean&quot;/&gt; &lt;value&gt;2&lt;/value&gt; &lt;bean class=&quot;com.shiyanlou.spring.collections.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Dark&quot;/&gt; &lt;property name=&quot;address&quot; value=&quot;Nanjing&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;25&quot;/&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; Set &lt;!-- java.util.Set --&gt; &lt;!--Set与List类似--&gt; &lt;property name=&quot;sets&quot;&gt; &lt;set&gt; &lt;value&gt;1&lt;/value&gt; &lt;ref bean=&quot;personBean&quot;/&gt; &lt;bean class=&quot;com.shiyanlou.spring.collections.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;setV&quot;/&gt; &lt;property name=&quot;address&quot; value=&quot;addV&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;25&quot;/&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; Map &lt;!-- java.util.Map --&gt; &lt;!--一个entry就是一个Map元素--&gt; &lt;property name=&quot;maps&quot;&gt; &lt;map&gt; &lt;entry key=&quot;Key 1&quot; value=&quot;1——map&quot;/&gt; &lt;entry key=&quot;Key 2&quot; value=&quot;2--map&quot;/&gt; &lt;entry key=&quot;Key 3&quot;&gt; &lt;!-- 临时创建一个对象 --&gt; &lt;bean class=&quot;com.shiyanlou.spring.collections.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;map_&quot;/&gt; &lt;property name=&quot;address&quot; value=&quot;jiangsu&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt; &lt;/bean&gt; &lt;/entry&gt; &lt;entry key=&quot;Key 4&quot; value-ref=&quot;personBean&quot;/&gt; &lt;/map&gt; &lt;/property&gt; properties &lt;!-- java.util.Properties --&gt; &lt;!-- Properties 类型类似于Map类型的特列 Map元素的键值可以对应任何类型的对象，但是Properties只能是 字符串 --&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;admin&quot;&gt;admin#oop.com&lt;/prop&gt; &lt;prop key=&quot;userName&quot;&gt;root&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;]]></content>
      <categories>
        <category>Spring关键字</category>
      </categories>
      <tags>
        <tag>集合类型的注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring关键字之依赖注入（Dependency Injection)]]></title>
    <url>%2F2019%2F03%2F01%2FSpring%E5%85%B3%E9%94%AE%E5%AD%97%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88Dependency-Injection%EF%BC%89%2F</url>
    <content type="text"><![CDATA[依赖注入： 应用组件的创建、装配由容器在运行期决定（即由容器动态的将某个依赖关系注入到组件之中） 装配：创建应用组件之间协作的行为 任何一个有实际意义的应用都会由两个或者更多的类组成，这些类之间的相互协作来完成特定的业务逻辑。 传统的方法 每个对象负责管理与自己相互协作的对象（即它所依赖的对象）的引用。 坏处 模块之间高度耦合 难以测试的代码 耦合的两面性（two-headed beast） 紧耦合代码 难以测试、难以复用、难以理解，将出现典型的“打地鼠”式的bug（修复一个bug，将出现一个或更多的bug）。 无耦合代码 完全没有耦合的代码什么也做不了。为了有实际意义的功能，不同的类必须以适当的方式进行交互。 Spring框架之后 对象的实例不再由调用者创建，而是由Spring容器创建，Spring容器负责控制程序之间的关系， DI的理解关键： “谁依赖谁，为什么需要依赖““谁注入谁，为什么需要注入“ 谁依赖谁 即某个容器管理的对象依赖于IoC容器 为什么需要依赖 即某个容器管理的对象需要IoC容器来提供对象所需要的外部资源 谁注入了谁 IoC容器注入依赖对象的对象（即某个容器管理的对象） 注入了什么 注入了某个对象所需要的外部资源（eg：对象、资源、常量数据） 理解IoC&amp;DI ===》 同一个概念的不同角度描述。 IoC：对象的创建交由外部容器完成。 DI： 实现对象之间的依赖关系。 Spring中给Bean属性注入value一般三种方法 属性setter方法注入 构造方法constructor注入 p schema方法 属性setter方法注入 ☞ 使用设值注入条件 提供默认空参构造方法 为所有属性提供setter方法 实例 POJO类 public class User { /** * 1. 使用构造注入 * 1.1 提供带所有参数的有参构造方法 * */ private String userName; private Integer password; private List list; public User(String userName, Integer password, List list){ super(); this.userName = userName; this.password = password; this.list = list; } /** * 2. 使用设值注入 * 2.1 提供默认空参构造方法 * 2.2 为所有属性提供setter方法 * */ public User(){ } public void setUserName(String userName){ this.userName = userName; } public void setPassword(Integer password){ this.password = password; } public void setList(List list){ this.list = list; } @Override public String toString() { return "User{" + "userName='" + userName + '\'' + ", password=" + password + ", list=" + list + '}'; } } 配置文件 ① 使用设值setter注入方式装配User实例 &lt;bean id=&quot;user2&quot; class=&quot;com.itheima.assemble.U &lt;property name=&quot;userName&quot; value=&quot;张三&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;632554&quot;&gt;&lt;/property&gt; &lt;!-- 注入list集合 --&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;&quot;setListValue1&quot;&lt;/value&gt; &lt;value&gt;&quot;setListValue2&quot;&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; ② 使用构造方法constructor注入方式装配User实例 &lt;bean id=&quot;user1&quot; class=&quot;com.itheima.assemble.User&quot;&gt; &lt;constructor-arg index=&quot;0&quot; type=&quot;java.lang.String&quot; value=&quot;Tom&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; type=&quot;java.lang.Integer&quot; value=&quot;123456&quot;/&gt; &lt;constructor-arg index=&quot;2&quot;&gt; &lt;list&gt; &lt;value&gt;&quot;constructorValue1&quot;&lt;/value&gt; &lt;value&gt;&quot;constructorValue2&quot;&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; ③ 使用p:schema命名空间注入（不推荐使用） &lt;bean id=&quot;user3&quot; class=&quot;com.itheima.assemble.User&quot; p:userName=&quot;W3c&quot; p:password=&quot;123&quot; p:list=&quot;test1&quot;/&gt; Spring Inner Bean - 内部嵌套的 Bean 一个 Bean 中嵌套了另一个 Bean ，即所谓的内部嵌套 Bean 的配置方法，内部嵌套的 Bean 支持属性（ property ）注入和构造函数（ constructor - arg ）注入。 这里的Bean装配方式总的来说都是XML装配还有其他的两种(注解装配和自动装配) setter方法注入 构造方法注入 ref属性注入 实例 CustomerBean中被注入PersonBean 即Customer类依赖于Person POJO类 Person.java public class Person { private String name; private String address; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return &quot;Person{&quot; + &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; + &quot;, address=&apos;&quot; + address + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &apos;}&apos;; } } Customer.java public class Customer { //==========构造方法注入========== private Person person; // 带参构造方法 public Customer(Person person){ this.person = person; } //==========setter方法注入========== // 有带参构造方法一定要有默认构造方法 public Customer(){} public void setPerson(Person person){ this.person = person; } @Override public String toString() { return &quot;Customer{&quot; + &quot;person=&quot; + person + &apos;}&apos;; } } 配置文件 ① 通过property属性即setter方法注入（要有一个无参构造器，两者的创建、关联融合在一起） 此方法步骤: 在customerBean的创建同时实例化另一个personBean(需要在Customer中写入【private Person person; + person‘s setter】) &lt;!-- 第二种方法 在Customer的Bean中声明一个内部Bean--&gt; &lt;bean id=&quot;customerBean2&quot; class=&quot;com.shiyanlou.spring.innerbean.Customer&quot;&gt; &lt;property name=&quot;person&quot;&gt; &lt;bean class=&quot;com.shiyanlou.spring.innerbean.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;wangzhuang&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt; &lt;property name=&quot;address&quot; value=&quot;Nanjing&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; ② 通过有参构造器同样在被注入对象的内部通过构造器注入（两者的创建、关联融合在一起） &lt;!-- 第三种方法 通过Customer的构造函数中注入--&gt; &lt;bean id=&quot;customerBean3&quot; class=&quot;com.shiyanlou.spring.innerbean.Customer&quot;&gt; &lt;constructor-arg&gt; &lt;bean class=&quot;com.shiyanlou.spring.innerbean.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Erick&quot;/&gt; &lt;property name=&quot;address&quot; value=&quot;jiangsu&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;25&quot;/&gt; &lt;/bean&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; ③ 通过ref属性引用来构建两者的关系即将一个对象作为引用被注入到另一个对象之中（两者独立创建通过 ref 进行关联） //////////////////////////////////// &lt;bean id=&quot;customerBean&quot; class=&quot;com.shiyanlou.spring.innerbean.Customer&quot; p:person-ref=&quot;personBean&quot;/&gt;&lt;br/&gt; // 也可以改为&lt;br/&gt; &lt;bean id=&quot;customerBean&quot; class=&quot;com.shiyanlou.spring.innerbean.Customer&quot;&gt; &lt;property name=&quot;person&quot; ref=&quot;PersonBean&quot; /&gt; &lt;/bean&gt; /////////////////////////////////// &lt;bean id=&quot;personBean&quot; class=&quot;com.shiyanlou.spring.innerbean.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;shiyanlou&quot;/&gt; &lt;property name=&quot;address&quot; value=&quot;chengdu&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;25&quot;/&gt; &lt;/bean&gt;]]></content>
      <categories>
        <category>Spring-Learning</category>
      </categories>
      <tags>
        <tag>Dependency Injection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架之Map和List遍历]]></title>
    <url>%2F2019%2F02%2F28%2F%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BMap%E5%92%8CList%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[集合接口 Type DESC Collection 最基本的集合接口，代表一组Object，存储着不唯一，无序的对象 List 一个有序的Collection，是一个不唯一，有序（插入顺序）的对象 Set Set具有与Collection完全一样的接口，只是行为上不同，不会保存重复的元素，存储一组唯一，无序的对象 SortedSet 继承于Set保存有序的集合 Map Map接口存储一组键值对象，提供key（键）到value（值）的映射 Map.Entry 描述在一个Map中的一个元素（键/值对）。是一个Map的内部类 SortedMap 继承于Map，使key保持在升序的排列 Set和List的区别 Set： 无顺序、无重复的数据 List：有序、重复的数据 Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置的改变* 实现类：HashSet、TreeSet List和数据类似，只不过可以动态增长，根据实际存储的数据长度自动增长的List长度。插入删除效率低，因为会引起其他元素位置改变* 实现类： ArrayList、LinkedList、Vector 遍历ArrayList package com.niit.count; import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class TestArrayList { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;test1&quot;); list.add(&quot;test2&quot;); list.add(&quot;test3&quot;); //第一种遍历方法使用foreach遍历List for(String str : list) { // 也可以改写for(int i = 0 ; i &lt; list.size(); i ++) System.out.println(str); } // 第二种遍历，把链表变为数组相关的内容进行遍历 String [] strArray = new String[list.size()]; list.toArray(strArray); for(int i = 0; i &lt; strArray.length; i++) { // 这里也可以改写为foreach(String str: strArray) System.out.println(strArray[i]); } // 第三种遍历 使用迭代器进行遍历 Iterator&lt;String&gt; ite = list.iterator(); while(ite.hasNext()) { System.out.println(ite.next()); } } } 遍历Map package com.niit.count; import java.util.HashMap; import java.util.Iterator; import java.util.Map; public class TestMap { public static void main(String[] args) { Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); map.put(&quot;1&quot;, &quot;value1&quot;); map.put(&quot;2&quot;,&quot;value2&quot;); map.put(&quot;3&quot;,&quot;value3&quot;); // 第一种， 普遍使用，二次取值 System.out.println(&quot;通过Map.keySet遍历key和value&quot;); for(String key : map.keySet()) { System.out.println(&quot;key= &quot; + key + &quot;, value= &quot; + map.get(key)); } // 第二种， System.out.println(&quot;通过Map.EntrySet使用iterator遍历map&quot;); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator(); while(it.hasNext()) { Map.Entry&lt;String, String&gt; entry = it.next(); System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value = &quot; + entry.getValue()); } // 第三种，推荐尤其是容量大的 for(Map.Entry&lt;String,String&gt; entry : map.entrySet()) { System.out.println(&quot;key= &quot; + entry.getKey() + &quot;and value= &quot; + entry.getKey()); } // 第四种，通过Map.values()遍历所有的value但不能遍历所有的可以、 for(String v : map.values()) { System.out.println(&quot;value= &quot; + v); } } }]]></content>
      <categories>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习Spring、Struts、Hibernate三大框架 --- 概论]]></title>
    <url>%2F2019%2F02%2F24%2F%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0Spring%E3%80%81Struts%E3%80%81Hibernate%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6-%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[基础概念：Spring、Struts、Hibernate是干嘛用的？ 三个框架产生的技术历史背景 学习前首先应该掌握基础知识 掌握学习一个开发框架的基本流程和步骤 Spring框架 ORM框架 MVC框架 Spring： DI&amp;AOP Spring对应的关键词：DI（依赖注入）&amp; AOP（面向切面编程） -&gt; 以DI和AOP为核心的JavaWeb一站式的集成框架。 1. DI(又称之为IoC即控制反转) ===》 管理Java对象之间的依赖关系。&lt;br/&gt; 2. AOP ===》 解耦业务代码和公共服务代码（eg：日志、安全、事务...） 让代码具有良好的松耦合性和可测试性 ==》 极大简化开发。 Struts: MVC Struts是一个基于MVC模式下的JavaEE框架。(MVC 早在1978年作为SmallTalk的一种设计模式被提出来) Model : 封装于业务逻辑有关的数据以及数据处理方法 View : 是数据的HTML展现 Controller ：负责响应请求，协调Model和View M|V|C的分开是一个典型的关注点分离的思想，不仅使得代码复用性和组织性更强而且使得Web应用的配置性和灵活性更好。 Hibernate ： ORM Hibernate 是一个Java ORM开发框架（ORM即Object Relation Mapping 即对象关系映射） ORM ==》 以面向对象的方式进行数据库操作的技术 通常Java进行数据库访问的正常流程分为以下几步： 建立数据库连接 准备好SQL语句（在SQL语句的拼接麻烦易出错） 利用JDBC的API传入SQL语句和设置参数（代码重复性高） 解析JDBC返回的结果（将结果转换成领域模型的Java对象很繁琐） 三个框架产生的技术历史背景 1991年===》 Web页面在Internet上首秀 【最早用于科学家之间共享和传递信息（静态文本）】 不满足于此 1993年===》 CGI（Common Gateway Interface）（CGI定义了Web服务器与外部应用程序之间的通信的标准） 因此Web服务器可以通过CGI来执行外部程序，让外部程序根据Web服务器接收到的请求不同来生成不同的动态内容。（Servlet Just Like it） 出现的问题：CGI程序的主要为Perl和C语言，在程序中嵌入大片的HTML字符串 ===》 可读性和维护性差。 处理办法： 1. 把HTML页面中固定的部分存起来（称之为模板），把动态部分打上标记，处理Web请求时，后端程序生成动态内容然后填充进到模板中去，形成最终返回的HTML 1994年===》 PHP可以把程序（动态内容）嵌入到HTML（模板中），而且效率比CGI更高。 1996年===》 ASP &amp; VB 1998年===》 JSP &amp; Java Web开发脚本语言 + 后端数据库技术 ===》 Web大杀四方。eg：电子商务系统这样的复杂应用也开发出现在互联网上。 MVC被引入Web应用开发中 Web Browser发送HTTP请求到服务端，被Controller（Servlet）获取并进行处理（eg：参数解析、请求转发） Controller(Servlet) 调用核心业务逻辑 — Model部分 Model进行数据库存取操作，并将操作结果返回给Model Controller（Serlvet）将业务逻辑处理结果交给View（JSP），动态输出HTML内容 动态生成的HTML内容返回到浏览器（前端）显示。 Spring MVC为例和ORM粉 Spring MVC提供了一个DispacherServlet（可以SpringMVC是一个Serlvet技术为基础的） Servlet把Web应用中Servlet中经常要实现的功能封装起来提供一层公共抽象，对应于一个Web请求后端要做的事情。 eg： + URL映射（对应HTTP URL和方法，应该调用什么代码） + 权限验证（当前的URL是否允许当前用户访问） + 参数解析（如果从Servlet中获得参数） + 数据绑定（如果将Serlvet中的参数，绑定到业务逻辑中） + 视图解析（使用哪个视图模板进行渲染） + 模型传递与视图渲染（将数据传递给模板，并且在模板中引用） 有了Spring MVC，你只需写简单的POJO代码（如图所示，用POJO实现Controller），或者实现Spring MVC给你提供的接口（比如实现Interceptor做权限判断），就能完成这些繁琐的功能。 &gt; POJO是Plain Old Java Object的缩写，是软件开发大师Martin Fowler提出的一个概念，指的是一个普通Java类。也就说，你随便编写一个Java类，就可以称之为POJO。之所以要提出这样一个专门的术语，是为了与基于重量级开发框架的代码相区分，比如EJB，我们编写的类一般都要求符合特定编码规范，实现特定接口、继承特定基类，而POJO则可以说是百无禁忌，灵活方便。 ORM的作用就非常直观了，无须赘述，eg：提供了与数据库操作的一层中间抽象。这样Model层代码就非常简单。 在更高的抽象层次上写程序了，更高的抽象层次一般意味着以更符合我们的思维方式来思考。eg： 从汇编语言发展处高级语言，从文件系统发展出数据库，其实本质规律是类似的。 需要了解的知识 回到历史，Web开始大杀四方之时，大型应用在分布式、安全性、事务性等方面的要求进一步催生了J2EE(现在已更名为Java EE)平台在1999年的诞生。但是J2EE的组件技术EJB（Enterprice Java Beans）非常笨重，Spring的初衷是为了替代EJB，让Java EE开发更加简单灵活。它起源于Rod Jahnson 2002年出版的著作《Expert One-on-One J2EE Design and Development》，那本书中分析了Java EE的开发效率和实际性能等方面的问题，从实践和架构的角度探讨了简化开发的原则和方法。以此为基础，他实现了一个名为interface21的轻量级开发框架，成为Spring框架的前身。2004年，Spring正式发布1.0版本，同年Rod Jahnson推出了另一部影响深远的经典著作《Expert one-on-one J2EE Development without EJB》，Spring开始逐步在Java领域流行。现在Spring框架的版本已经演化到了4.x，它已经成为Java开发框架的一种事实标准，对Java EE规范本身也产生了重要影响。比如EJB规范就在发展中逐渐引入了众多Spring框架的优秀特征。好了，你现在应该可以从更高和更广的技术视野来看待这几个框架了吧。看到一门技术的发规律和发展历程，这是一种技术修养的体现，跟人文修养是类似。但是同时我们也应该具有一定的深度，因为我们往往已经站在比较高的抽象层次，比如今天你写几行代码就能把数据库创建好，增删改查的功能也自动生成好了，但是成为高手需要你对底层的原理机制有更透彻的理解，真正遇到问题的时候才能抽丝剥茧迎刃而解。所以要看第三部分：需要了解的基础知识。]]></content>
      <categories>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>SSH 轻量级框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java四种访问权限修饰符]]></title>
    <url>%2F2019%2F02%2F24%2FJava%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[Java权限修饰符private、default、protected、public置于类的成员定义之前，用来限定对象对该类成员的访问权限。 修饰符 类内部 同一个包 子类 任何地方 private Yes （缺省）default Yes Yes protected Yes Yes Yes public Yes Yes Yes Yes 对于class的权限修饰只可以用public和default（缺省） default可以在同一个包中 protected可以在子类中 public任何地方]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>Java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之模板模式]]></title>
    <url>%2F2019%2F01%2F11%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式之模板模式模板方法模式的实现要素 准备一个抽象类 将部分逻辑以具体方法的形式实现 声明一些抽象方法交由子类实现剩余逻辑 用钩子方法给予子类更大的灵活性 最后将方法汇总构成一个不可改变的模板方法 抽象基类 具体子类 集成共性处理异点模板方法模式的适用场景 算法或操作遵循相似的逻辑 重构时（把相同的代码抽取到父类中） 重要、复杂的算法，核心算法设计为模板算法 模板方法模式的优点 封装性好 复用性好 屏蔽细节 便于维护 模板方法模式的缺点 继承性 知识点 什么是模板方法模式 如何实现模板方法模式 模板方法模式的特点 模板方法模式在项目中的应用 生活中的模板 实例抽象基类，为所有子类提供一个算法框架 package com.imooc.template; /** * 抽象基类，为所有子类提供一个算法框架 * * 业务：提神饮料 * */ public abstract class RefreshBeverage { /** * 制备饮料的模板方法 * 封装了所有子类共同遵循的算法框架 * */ public final void prepareBeverageTemplate() { //步骤一：将水煮沸 boilWater(); //步骤二: 泡制饮料 brew(); //步骤三：将饮料倒入杯中 pourInCup(); //步骤四：加入调味料 （添加个性化操作），默认的模式下加入调料 if(isCustomerWantsCondiments()) { addCondiments(); } } /** * Hook，钩子函数，提供一个默认或空的实现 * 具体的子类可以自行决定是否挂钩以及如何挂钩 * 询问用户是否加入调料 * */ protected boolean isCustomerWantsCondiments() { return true; } /* * 基本方法，将水煮沸 * */ private void boilWater() { // TODO Auto-generated method stub System.out.println("将水煮沸"); } /** *基本方法，将饮料倒入杯中 * */ private void pourInCup() { // TODO Auto-generated method stub System.out.println("将饮料倒入杯中"); } /* * 抽象的基本方法，泡制饮料 * */ protected abstract void brew(); /** * 抽象的基本方法，加入调味料 * */ protected abstract void addCondiments(); } 具体子类咖啡制作的具体实现 package com.imooc.template; public class Coffee extends RefreshBeverage{ /** * 具体子类，提供了咖啡制备的具体实现 * */ @Override protected void brew() { System.out.println("用沸水冲泡咖啡..."); } @Override protected void addCondiments() { System.out.println("加入糖和牛奶..."); } } 具体子类茶的具体实现 package com.imooc.template; public class Coffee extends RefreshBeverage{ /** * 具体子类，提供了咖啡制备的具体实现 * */ @Override protected void brew() { System.out.println("用沸水冲泡咖啡..."); } @Override protected void addCondiments() { System.out.println("加入糖和牛奶..."); } } 基于基类和其子类创建相应的对象并实现指定的功能 package com.imooc.template; public class RefreshBeverageTest { public static void main(String[] args) { System.out.println("《《《《《制做咖啡》》》》》"); RefreshBeverage b1 = new Coffee(); b1.prepareBeverageTemplate(); System.out.println("《《《《《Over》》》》》"); System.out.println("*******************************"); System.out.println("——————泡茶——————"); RefreshBeverage b2 = new Tea(); b2.prepareBeverageTemplate(); System.out.println("-----Over-----"); } } //《《《《《制做咖啡》》》》》 //将水煮沸 //用沸水冲泡咖啡... //将饮料倒入杯中 //加入糖和牛奶... //《《《《《Over》》》》》 //******************************* //——————泡茶—————— //将水煮沸 //用80度的热水浸泡茶叶5分钟 //将饮料倒入杯中 //加入柠檬🍋 //-----Over----- 具体分析抽象基类####（1）基本方法 /** * 基本方法，将水煮沸 */ private void boilWater(){ System.out.println("将水煮沸"); } /** * 基本方法，将饮料倒入杯中 */ private void pourInCup(){ System.out.println("将饮料倒入杯中"); } (2) 抽象方法 /* * 抽象的基本方法，泡制饮料 */ protected abstract void brew(); /* * 抽象的基本方法，加入调味料 */ protected abstract void addCondiments(); (3) 可选的钩子 /* * Hook， 钩子函数，提供一个默认或空的实现具体的子类可以自行决定是否挂钩以及如何挂钩询问用户是否加入调味料 */ protected boolean isCustomerWantsCondiments(){ return true; } 具体子类（1）实现基类中的抽象方法 eg：咖啡 —&gt; 冲泡 /* * 具体子类，提供了咖啡制备的具体实现 */ public class Coffee extends RefreshBeverage{ @Override protected void brew(){ System.out.println("用沸水冲泡咖啡"); } @Override protected void addCondiments(){ System.out.println("加入糖和牛奶"); } } eg: 茶 —&gt; 浸泡 /* * 具体子类， 提供了制备茶的具体实现 */ public class Tea extends RefreshBeverage{ @Override protected void brew(){ System.out.println("用80度的热水浸泡茶叶5分钟"); } @Override protected void addCondiments(){ System.out.println("加入柠檬🍋"); } } （2）覆盖钩子（Hook)方法 茶（不加调料） /* * 具体子类，提供了制备茶的具体实现 */ public class Tea extends RefreshBeverage{ @Override protected void brew(){...} @Override protected void addCondiments(){...} @Override /** * 子类通过覆盖的形式选择挂载钩子函数 */ protected boolean isCustomenrWantsCondiments(){ return false; //不要调料 } } 咖啡（加糖和牛奶） /* * 具体子类，提供了咖啡制备的具体实现 */ public class Coffee extends RefreshBeverage{ @Override protected void brew(){ System.out.println("用沸水冲泡咖啡"); } @Override protected void addCondiments(){ System.out.println("加入糖和牛奶"); } }]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之模板模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F2019%2F01%2F11%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式—单例模式(Singleton Pattern) Intro Item Desc 单例模式 Singleton 应用场合 有些对象只需要一个就足够了。具有唯一性质的实体 作用 保证整个应用程序中某个实例有且只有一个。 类型 饿汉模式、懒汉模式 Type 饿汉模式 懒汉模式 Testing 饿汉模式与懒汉模式之间的区别 饿汉模式的特点是加载类时比较慢，但运行时获取对象的速度较快，线程安全 懒汉模式的特点是加载类时比较快，但运行时获取对象的速度较慢，线程不安全]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式之单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL Server基础知识点01]]></title>
    <url>%2F2019%2F01%2F11%2FSQL-Server%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B901%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础知识点01]]></title>
    <url>%2F2019%2F01%2F11%2FJavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B901%2F</url>
    <content type="text"><![CDATA[1 . BOM对象 |- window |- document |- anchors |- forms |- images |- links |- location |- frames |- history |- location |- screen |- navigator 2 . 易错点 null == undefined //true null === undefined //false false = 0; //√ true = 1; //√ true = 2; //❌ '100' = 100 //true parseInt("123.236"); //123 parseFloat("123.236"); //123.236 parseInt("a123");// NaN 一元 > 算术 > 关系 > 逻辑 > 赋值 3 . 变量的作用域 * 全局变量: 在函数外部定义 * 局部变量: 在函数内部定义 * 同名时： 局部变量有效 4 . 常见的事件 * 浏览器窗口（body）： onload、unload事件（页面加载与关闭） * 页面元素 * onMouseMove(0) * onMouseOver * onMouseOut * onMouseDown * onMouseUp 鼠标操作时发生]]></content>
      <categories>
        <category>JavaScript基础知识点01</category>
      </categories>
      <tags>
        <tag>JavaScript基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件测试基础知识点02]]></title>
    <url>%2F2019%2F01%2F11%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B902%2F</url>
    <content type="text"></content>
      <categories>
        <category>软件测试期末复习</category>
      </categories>
      <tags>
        <tag>软件测试期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心模式_DAO设计模式]]></title>
    <url>%2F2019%2F01%2F08%2FJava%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%BC%8F-DAO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[需要理解的知识点（核心内容） 理解程序设计分层的思想 DAO设计模式的组成以及各部分的开发 1. 程序的分层 实际上在任何的环境下分层的概念都会存在，eg：公司中职位的分层。]]></content>
      <categories>
        <category>DAO设计模式</category>
      </categories>
      <tags>
        <tag>Java核心模式-DAO设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript札记]]></title>
    <url>%2F2019%2F01%2F06%2FJavaScript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JavaScript语法 JavaScript是什么? 客户端脚本语言 基于对象（Object）和事件驱动（Event） JS基本数据类型 Number String Null Undenfined Boolean 变量定义以及命名规则：先定义后使用，直接使用会出错。 var m,n; //声明变量 var x,y,z = 10; 注释两种 // /***/ 类型转换 parseInt(“123”) 123 parseInt(“a123”) NaN parseInt(“5.455”) 5 parseInt(“5.455”) 5.455 运算符 关键词 描述 () ! ++ == - 一元操作符 * / + - 算术运算符 &lt; &lt;= &gt; &gt;= 关系运算符 &amp;&amp;.. 逻辑运算符 = += *= /= %= 赋值运算符]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Use---Mac]]></title>
    <url>%2F2019%2F01%2F03%2FUse-Mac%2F</url>
    <content type="text"></content>
      <categories>
        <category>Mac的使用</category>
      </categories>
      <tags>
        <tag>Mac的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识点]]></title>
    <url>%2F2018%2F12%2F29%2FPython%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Keywords DESC 运算符 +、-、*、/、% 运算顺序 先乘除再加减括号最优先 变量 一个标签，由非数字开头的字母、数字、下划线组成 内容 数值、字符串、列表、元祖和字典 数值 数字。a = 100 字符串 “ “、’ ‘ 转义字符 \t(tab)、\n(换行)、\”转义”、&amp;s（占位），用%后的变量替换 元祖（），誓言，一旦定义不能改变 f = (1,2,3) 字典{} {key:value} 修改 字典名[key] = value 删除 del 字典名[key] 插入 字典名[key]=value VIM 文件名 打开或新建文件在VIM中点击i进入插入模式，可以向文本中写入内容 Key Value ESC + q 退出VIM ESC + wq 保存更改退出VIM ESC + q! 不保存更改退出VIM 循环语句 for var in range(start,end): ***** --------------------------- for var in 列表名: ***** --------------------------- while 条件: ***** --------------------------- 终止循环用 break turtle 模块 🐢 import turtle # 导入turtle模块 t = turtle.Pen() # 用turtle模块中的Pen类，实例化出一个叫做t的对象 t.forward(像素点) t.backward(像素点) t.left(角度) t.right(角度) t.reset() # 复位 函数 模块 包 函数： 执行某些操作的一段代码 eg: Input() 定义函数： def 函数名 (参数表): 函数体 定义： def hi_name(yournme): print("Hello %s" yourname) 使用: hi_name("张三") 输出: Hello 张三 函数返回值：return def add(a, b): return a + b c = add(5, 6) # c被赋值为add的返回值11 内建函数：python解释器自带的函数 abs(-10) 返回10 变量作用域 Key Value 局部变量 在函数定义的变量，只在函数中存在，函数执行结束不可再用 全局变量 在函数前定义的变量，一般在整个代码最前面定义，全局可用 类 对象 面向对象 |类|物以类聚人以群分，是函数的集合，可实例化出对象的摸具||实例化|对象 = 类() t = turtle.Pen()||对象|是类实例化出的实体，对象存在完成具体工作||面向对象|程序员反复修改优化类，类实例化出对象，对象调用函数执行具体的操作。|]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习---Python快速复习]]></title>
    <url>%2F2018%2F12%2F29%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-Python%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Python Intro 类型：解释型 特点：简单明确 作者：Guido van （荷兰人） 实践： 1991年，第一版基于C实现的Python编译器诞生。 优点： 可以轻松地用其他语言编写模块供调用。 底层复杂且对效率要求高地模块用C/C++等语言实现 顶层调用的API用Python封装———-&gt; 故Python被称为胶水语言。 更多地实践在思考问题地逻辑。 Python基本语法数据类型12345a = 1 # 整形b = 1.2 # 浮点数c = True # 布尔类型d = &quot;False&quot; # 字符串e = None #NoneType != 0 运算符 a = 2 b = 2.3 c = 3 a / b # 整数除以浮点数，运算以浮点数为准 2 / 2.3 = 0.8695652173913044 3 / 2 = 1.5 # Python3中 ”/“中属于正常除法得到什么就是什么 3 // 2 = 1 # Python3中 ”//“中属于整除向下取整 eg：1.87 取 1 3 ** 2 = 9 # 即3的2次方 3 ** 3 = 27 # 即3的3次方 操作符 ~8 # 按位翻转，1000 --> -(1000+1) 8 >> 3 # 右移3位，1000 --> 0001 1 < 3 # 左移3位，0001 --> 1000 5 & 2 # 按位与，101 & 010 = 000 5 | 2 # 按位或，101 | 010 = 111 4 ^ 1 # 按位异或，100 ^ 001 = 101 >> g = [0]*3 + [1]*4 + [2]*2 >>> g [0, 0, 0, 1, 1, 1, 1, 2, 2] 列表的基本访问 a.pop() # 把最后一个值4从列表中移除并作为pop的返回值 a.append(5) # 末尾插入值[1,2,3,5] a.index(2) # 找到第一个2所在的位置也就是1 a[2] # 找到第一个2所在的位置也就是1 a += [4, 3, 2] # 拼接[1,2,3,5,4,3,2] a.insert(1, 0) # 在下标为1处插入元素0,[1, 0, 2, 3, 5, 4, 3, 2] a.remove(2) # 移除第一个2 a.reverse() # 反转 a[3] = 9 # 指定下标赋值[2, 3, 4, 9, 3, 0, 1] b = a[2:5] # 取下标2开始到5(不到5)之前的子序列[4, 9, 3] e = a[:5] # 从索引0取到5之前 f = a[:] # 取出开头到最后的整个序列相当于复制 g = a[::-1] # 倒序，通过slicing实现并赋值，效率低于reverse() a.sort() print(a) # 列表内排序，a变为[0,1,1,2,2,3,3] 列表是有序的，所以和顺序相关的操作是列表中最常见的，先打乱一个列表的顺序，然后再对这个列表的排序： import random a = range(10) # 生成一个列表，从0开始递增到9 # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] random.shuffle(a) # shuffle函数可以对可编列且可变结构打乱顺序 b = sorted(a) print(b) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] c = sorted(a, reverse = True) print(c) # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] 元组（Tuple） 元组和列表有很多相似的地方，但元组的最大区别在于一旦定义就不可改变，还有如果初始化只包含一个元素的tuple和列表不一样，因为语法必须明确，所以必须在元素后加上逗号。另外直接用逗号分割多个元素赋值默认是个tuple，这在函数多返回值的时候非常好用； a = (1, 2) b = tuple(['3'], 4) # 也可以从列表初始化 c = (5,) print(c) #(5,) d = 6 print(d) # 6 e = 3, 4, 5 # print(e) #(3, 4, 5) 集合 集合是一种很有用的数学操作，eg：列表去重，或是理清两组数据之间的关系，集合的操作符和位操作符有交集 A = set([1, 2, 3, 4]) B = {3, 4, 5, 6} C = set([1, 1, 2, 2, 3, 3, 3, 3]) print(c) # 集合的去重效果, set([1, 2, 3]) print(A | B) # 求并集， set([1, 2, 3, 3, 4, 5, 6]) print(A & B) # 求交集，set([3,4]) print(A - B) # 求差集， 属于A但不属于B的set([1, 2]) print(B - A) # 求差集， 属于B但不属于A的set([5, 6]) print(A ^ B) # 求对称差集，相当于（A-B）|（B-A），set([1, 2, 5, 6]) 字典（Dict） 字典是一种非常常见的“key-value”映射结构，键无重复，一个键不能对应多个值，不过多个键可以对应一个值。 a = {'Tom' : 8, 'Jerry' : 7} print(a['Tom']) # 8 b = dict(Tom=8, Jerry=7) # 一种字符串作为键更方便的初始化方式 print(b['Tom']) # 判断’Jerry'是否在keys里面 if 'Jerry' in a: print(a['Jerry']) # 7 print(a.get('Spike')) # None, 通过get获得值，即使键不存在也不会报异常 a['Spike'] = 10 a['Tyke'] = 3 a.update({'Tuffy' : 2, 'Mammy Two Shoes' : 42}) print(a.values()) # dict_values([8, 2, 3, 7, 10, 42]) print(a.pop('Mammy Two Shoes')) # 移除Mammy Two Shoes的键值对，并返回42 print(a.values()) # 返回所有的值 dict_values([8, 2, 3, 7, 10, 42]) print(a.pop('Mammy Two Shoes')) # 移除Mammy Two Shoes的键值对，并返回42 print(a.keys()) # dict_keys(['Tom','Tyffy','Jerry','Spike']) 初始化字典和集合很像，集合只是没有值的字典。在Python3.6之前字典是映射关系即没有顺序，可以将(key,value)这种对进行排序，是没有问题的，前提是字典转化成可排序的结构，items()或者iteritems()可以做到这些事情。 b = a.items(); print(b) # [('Tuffy', 2), ('Spike', 10), ('Tom', 8), ('Tyke', 3), ('Jerry', 7)] from operator import itemgetter c = sorted(a.items(), key=itemgetter(1)) print(c) # [('Tuffy', 2), ('Tyke', 3), ('Jerry', 7), ('Tom', 8), ('Spike', 10)] d = sorted(a.iteritems(),key=itemgetter(1)) print(d) # [('Tuffy', 2), ('Tyke', 3), ('Jerry', 7), ('Tom', 8), ('Spike', 10)] e = sorted(a) print(e) # 只对键排序，['Jerry', 'Spike', 'Tom', 'Tuffy', 'Tyke'] items()可以把字典中的键值对转化成一个列表，其中每个元素是一个tuple，tuple的第一个元素的键，第二个元素是值。变量c是按照值排序，所以需要一个操作符itemgetter，去位置为1的元素作为排序参考，如果直接对字典排序，则其实相当于只是对键排序。字典被当作一个普通的可遍历结构时，都相当于遍历字典的键。如果觉得字典没有顺序不方便，可以考虑使用OrderedDict a = {1: 2, 3: 4, 5: 6, 7: 8, 9: 10} b = OrderedDict({1: 2, 3: 4, 5: 6, 7: 8, 9: 10}) print(a) # {1: 2, 3: 4, 9: 10, 5: 6, 7: 8} print(b) # OrderedDict([(1, 2), (3, 4), (9, 10), (5, 6), (7, 8)]) Guido宣布在Python3.6中，字典将默认有序而且。在Python3中，range()就不再产生一个列表了，而是作为迭代器，xrange()直接没了。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公共基础知识]]></title>
    <url>%2F2018%2F12%2F27%2F%E5%85%AC%E5%85%B1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[算法 算法：解题方案的准确而完整的描述。 算法不等于 程序 计算机方法 程序的编制不可能优于算法的设计 算法的特征： 可行性 确定性（步骤明确定义） 有穷行（有限时间做完） 算法的基本要素： 对数据对象的运算和操作 算法的控制结构（顺序结构、选择结构、循环结构） 算法复杂度（两者之间无联系） 算法时间复杂度：计算工作量 算法空间复杂度：内存空间 数据结构的基本概念 数据结构（相互有关联的元素的集合）研究的三个方面 数据逻辑结构（数据集合中各数据元素之间所固有的逻辑关系） 数据存储结构（各数据元素在计算机中的存储关系） 对各种数据结构进行的运算 数据的存储结构：顺序、链接、索引 线性结构条件 有且只有一个根节点； 每个节点最多有一个前件，也最多有一个后件； 线性表及其顺序存储结构 线性表：一组数据元素构成（数据元素的位置只取决于自己的序号，元素之间的相对位置是线性的） 若干项数据元素组成的数据元素：记录 若干项记录构成的线性表：文件 线性表的顺序存储结构的两个基本特点： 线性表中所有元素的所占的存储空间是连续。 线性表中各数据元素在存储空间按逻辑顺序依次存放的 栈和队列 栈（🍾）：限定在一端进行插入与删除的线性表 先进后出FILO 支持子程序调用 具有记忆功能 可以不用顺序存放数据 只能在top首部进行操作，bottom是绝对不动的。 栈存放的数据个数 num = （bottom - top ) + 1; 队列（🚃）：指允许在一端（队尾）进入插入在另一端进行删除的线性表 先进先出FIFO或者后进后出（LILO） 循环队列里面的个数计算方法: rear &gt; front : num = rear - front; front &gt; rear : num = read + n - front;线性链表 数据结构中每个节点对应一个存储单元（结点） 结点的组成： 用于存储数据元素值（数据域） 用于存放指针（指针域） 链式存储结构中，存储数据结构的存储空间可以不连续 数据元素之间的逻辑关系是由指针来确定的。 链式存储方式即可用于表示线性结构，也可用于表示非线性结构。 线性链表：查找、插入、删除 树与二叉树 树：非线性结构，所有元素之间具有明显的层次关系。 没有前件的结点只有一个：树的根结点。（树的根） 每个结点可以有多个后件，称为该结点的子结点。 没有后件的结点：叶子结点 一个结点所拥有后件的个数称为该结点的度 所有结点中最大度称为树的度 树的最大层次称为树的深度 二叉树的特点： 非空二叉树只有一个根结点 每一个结点最多有两颗子树，（结点的左子树和右子树） 二叉树的性质（★★★） 查找技术 顺序查找的使用情况: 长度为n的线性表：找出一个数据，最差情况比较n次 长度为n的线性表：找出一个最大数据，最差的情况比较n - 1次 二分法查找只是用顺序存储的有序表 二分查找：对于长度为n的有序线性表：最坏的情况log2n次 排序技术 排序是指将一个无序序列整理成按值非递减排列的有序序列 交换类排序： 冒泡排序 比较次数： n(n-1)/2; 快速排序 比较次数：n(n-1)/2; 插入类排序： 简单插入排序：最坏情况下：n(n-1)/2 希尔排序：最坏情况下：n(n-1)/2 选择类排序： 简单选择排序：最坏情况下n(n-1)/2 堆排序: 最坏情况下O(nlog2^n) 程序设计基础 程序设计风格 注释分序言性注释和功能性注释，语句结构清晰第一，效率第二 程序一定要求具有易读性、可读性较好 程序设计方法有两种：结构化程序设计和面向对象程序设计 结构化程序设计 结构化程序设计方法得四条原则是: 自顶向下 逐步求精 模块化（★） 限制使用goto语句 结构化程序得基本结构和特点 顺序结构 选择结构 循环结构 面向对象的程序设计，以对象为核心。 面向对象具备的基本概念 对象、类和实例、消息、继承、多态性 对象是面向对象方法中最基本的概念，对象是实体的抽象。 属性是对象所包含的信息，操作描述了对象执行的功能，操作也称为方法或服务。 对象的基本特点： 标识唯一性 分类性 多态性 继承 封装 类是具有共同属性、共同方法的对象的集合，类是对象的抽象，对象是对应类的 消息是一个实例与另一个实例之间传递的信息。 消息的组成包括： 接收消息的对象的名称； 消息标识符，也称为消息名 零个或多个参数 继承是指能够直接获得已有的性质和特征，而不必重复定义他们。 继承分单继承和多重继承。对象也可以没有继承 单继承：一个类只允许有一个父类。 多重继承：一个类允许有多个父类。 多态性：同样的消息被不同的对象接受时可导致完全不同的行动的现象 软件工程基础 软件工程基本概念 计算机软件：程序、数据以及相关文档的完整集合。 软件的特点： 软件是一种逻辑实体。 软件的生产与硬件不同，没有明显的制作过程 软件在运行、使用期间不存在磨损、老化问题 软件按功能分为应用软件、系统软件、支撑软件（工具软件） 数据库管理系统是系统软件。 教务处管理系统是应用软件。 软件危机主要表现在成本、质量、生产率等问题 软件工程是应用于计算机软件的定义、开发和维护的一整套方法、工具、文档、实践标准和工序。 软件工程包括3个重要的要素：方法、工具、过程 方法：完成软件工程的技术手段。 工具：支持软件的开发、管理、文档生成。 过程：支持软件开发的各个环节的控制、管理 软件工程过程是把软件转化为输出的一组彼此相关的资源和活动。包含4种基本活动； P— 软件规格说明； D— 软件开发 C— 软件确认 A— 软件演进 软件生命周期：软件产品从【提出】-&gt;【实现】-&gt;【运行维护】主要活动阶段是：需求分析即定义阶段。 详细设计和概要设计的开发阶段 软件的目标： 在给定成本、进度的前提下，开发出具有有效性、可靠性、可理解性、可维护性、可重用性、可适应性、可移植性、可追踪性和可互操作且满足用户需求的产品。 基本原则：抽象、信息隐蔽、模块化、局部化、确定性、一致性、完备性和可验证性。 软件开发技术：软件开发方法学、开发过程、开发工具和软件工程环境。 软件工程管理：软件管理学、软件工程经济学、软件心理学等内容 软件管理学：人员组织、进度安排、质量保证、配置管理、项目技术等。 结构化分析方法 结构化方法的核心和基础：结构化程序设计理论 需求分析方法 结构化需求分析法 面向对象的分析的方法 需求分析阶段4个方面： 需求获取 需求分析 编写需求规格说明书（★） 需求评审 雪球分析建立的模型的特性来分：静态分析和动态分析*结构化分析方法的实质：面向数据流，自定向下，逐层分解，建立系统的处理流程，以数据流图和数据字典作为主要工具，建立系统的逻辑模型。 结构化分析的常用工具： 数据流图 数据字典 判定树 判定表 数据流图： 描述数据处理过程的工具，是需求理解的逻辑模型的图形表示，它直接支持系统功能建模； 数据字典：（结构化分析的核心。） 对所有与系统相关的数据元素的一个有组织的列表，以及精确的、严格的定义，使得用户和系统分析员对于输入、输出、存储成分和中间计算结果有共同的理解。 软件需求规格说明书的特点：无歧义性 正确性、无歧义性、完整性、可验证性、一致性、可理解性、可追踪性 结构化设计方法 软件设计的基本目标：比较抽线概括的方式确定目标系统如果完成预定的任务。 软件设计是确定系统的物理模型 软件设计是开发阶段最重要的步骤： 将需求准确地转化为完整地软件产品或系统的唯一途径。 从技术观点看：软件设计 软件结构设计 数据设计 接口设计 过程设计 从工程管理角度来看：概要设计和详细设计。 软件设计的一般过程： 软件设计是一个迭代的过程 先进行高层次的结构设计后进行底层设计的过程设计 穿插进行数据设计和详细设计 衡量软件模块独立性使用耦合性和内聚性两个定性的度量标准。 耦合性：对一个软件结构不同模块之间互联程度的度量 内聚性：一个模块内部各个元素之间彼此结合的紧密程度的度量 在程序结构中各模块的内聚性越强，则耦合性越弱。优秀软件应该：高内聚、低耦合。 软件概要设计的基本任务： 设计软件的系统结构 数据结构及数据库设计 编写概要设计文档 概要设计文档评审 模块用一个矩形表示，箭头表示模块间的调用关系。用带注释的箭头表示模块调用过程中来回传递的信息。还可用带实心圆的箭头表示传递的是控制信息，空心圆箭心表示传递的数据。 结构图的基本形式：基本形式、顺序形式、重复形式、选择形式 结构图四种模块类型：传入模块、传出模块、变换模块和协调模块。 典型的数据流类型有两种：变换类型和事务型。 变换型系统结构图由输入、中心变换、输出三部分组成。 详细设计：是为软件结构图中的每一个模块确定的实现算法和局部数据结构，用某种特定的表达工具表示算法和数据结构的细节。 常见的过程设计工具：（☆★☆） 过程设计工具 描述 图形工具 程序流程图、N-S图、PAD图、HIPO图 表格工具 判定表 语言工具 PDL 程序流程图： -&gt; 箭头表示控制流 💠 菱形表示逻辑条件 软件测试 软件测试定义： 使用人工或自动手段来运行或测定某个系统的过程，其目的在于检查它是否满足规定的需求或是弄清预期结果与实际结构之间的差别。 软件测试的目的：发现错误而执行程序的过程 软件测试方法：静态测试和动态测试 静态测试：代码检查、静态结构分析、代码质量度量、不实际运行软件. 动态测试：是计算机的测试，包括白盒测试和黑盒测试 白盒测试：内部进行。逻辑覆盖、基本路径测试 黑盒测试：功能性测试 白盒方法：逻辑覆盖测试、基本路径测试 黑盒方法：等价类划分法、边界值分析法、错误推测法、因果图 软件测试：单元测试、集成测试、验收测试、系统测试 程序调试 任务：诊断和修正程序中的错误。主要在开发阶段进行 软件调试： 静态调试：人的思维来分析源程序代码和排错。 动态调试：辅助静态调试 调试方法：1. 强行排错法2.回溯法3.原因排除法 数据库设计基础 数据：实际上是描述事物的符号记录； 数据的特点：有一定的结构，有型与值之分，eg：整型、实型、字符型等。 数据库：长期存储在计算机内部的、有组织、可共享的数据的集合。数据库存放数据是按数据所提供的数据模式存放的具有集成与共享的特点。]]></content>
      <categories>
        <category>公共基础知识</category>
      </categories>
      <tags>
        <tag>公共基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二级JavaA01]]></title>
    <url>%2F2018%2F12%2F27%2F%E4%BA%8C%E7%BA%A7JavaA01%2F</url>
    <content type="text"><![CDATA[简单的数据类型知识点 在Java语言中，所有的数据类型的长度均为固定值，因此没有sizeof保留字 Java的数据类型长度都是固定，变量的大小却决于变量的类型。 变量： 变量属性是用来描述变量作用域的 局部变量作用域只能是它所在方法的代码段 类变量的作用域是整个类 实型变量在运算中不会产生溢出的问题 实型变量如果下溢，则计算机设置为0.0 实型变量如果上溢，则计算机设置为+=Infinity（正/负无穷大） char类型在内存中占16位。 r 回车 n换行符 byte类型的范围：【-128~127】 以 0 开头的整数代表8进制整型常量 以 0X或0x开头的整数代表16进制整型常量 对于boolean类型的数据，作为类成员变量的时候，系统默认的初始值为false long类型的默认值【0L】不能有小数点 【char类型】可以自动转换为除了boolean类型数据之外的任何类型数据。 float f = 222.111f 浮点型的描述 浮点型数据属于实型数据 浮点型数据由数字和小数组成 浮点型数据包括实型常量和实型变量 运算符和表达式 一元算术表达式（++或者–运算符构成） &amp;&amp;运算符的操作数只能是布尔类型的数值int或者char类型的数值都不可以作为操作数。 ||布尔逻辑运算符实现操作数的逻辑或操作 布尔逻辑运算符 ！ &amp;&amp; || | —&gt; 按位或运算符 float + int = float short + short = int Java中的布尔型只有true和false两个值不可以用0和1替换 浮点数不能进行移位运算符。 😀 int x = ‘A’; x %= ‘A’; x = 0 流程控制 switch(x) 中x的数据类型只支持byte short int 和char]]></content>
      <categories>
        <category>二级Java</category>
      </categories>
      <tags>
        <tag>二级Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java二级]]></title>
    <url>%2F2018%2F12%2F25%2FJava%E4%BA%8C%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Java语言概述Java语言的实现机制 JVM（Java虚拟机） 12345Java语言是一种**解释执行**语言。虚拟机执行的有三个特点： * 多线程 * 动态链接 * 异常处理 垃圾回收机制 1Java语言提供了一个系统级的线程，实现对内存使用的监控，在程序不需要时间回收限制不用的内存，减轻了对内存挂历的符合。 代码的安全检验 Java的API结构 java.lang: 包括Object、Class和System等。 * Object是所有类的根类，任何类都是继承该类而建立的。 Class类由编译器动态生成对象的一个伴随每个类的特殊类（提供所对应的类的所有信息） System类是一个final类，主要提供标准I/O和对系统环境信息的访问，该类不能实例化。 java.awt 窗口工具包，提供操作图形用户界面的基本功能 java.applet 封装Applet类的包 java.io 封装I/O操作的包 java.util 工具类 常错的知识点： Java程序源文件名必须和public类名相同，否则编译出错 Java虚拟机执行特点：1.多线程2.动态链接3.异常处理 堆栈溢出在解释执行时进行检查； 内存跟踪：为了充分利用资源，Java语言提供了一个系统级别的线程，用于监控内存，在有必要时释放不再使用的内存：【垃圾回收机制】 Java中使用的是多线程技术，而不是多进程。进程概念是从操作系统角度考虑程序运行。 跨平台是Java语言所特有的，在不同的系统上，只要装有JVM就可以解释执行Java程序。 分布式计算是Java语言的一个重要特性，提供了在网络环境中的编程方法； Java语言是解释执行的，而不像是C++是编译执行的。 接口是用来实现多重继承的一种方法，Java通过这种方法提高类继承的灵活性和扩展性。 Java源文件以.java后缀，Java字节码文件以.class后缀，而Java源文件只有一个public类，该类的名字为源文件名。 Java语言一个源程序可以含有多个类，每个类编译都生成一个字节码文件 Java中最基本的元素就是对象，一切概念 都是以对象为基础的。 在创建Applet应用程序时，需要用户考虑的问题是：绘制的图形在窗口中的位置。 用于定义类头的修饰符可以是public、abstract、final、默认（friendly） 对象是客户世界不同实体的抽象。 类是某些具有共同属性的实体集合是对象的抽象（具有相同属性和行为）。 多线程是Java并发机制。能够处理同步共享数据和各种不同的事件。 Java程序由编译器编译成字节码文件，后由JVM解释器执行字节码文件。 半编译和半解释，一般都认为Java语言都是解释执行的。 在程序中，对象是一种抽象数据类型来描述的，这种抽象数据类型称为类。 Java语言是一个C++为基础的。 所有类必须实例化，才能调用它的数据成员和方法。× System类不能实例化，它的所有方法都是通过类变量来调用的√ 为了区分重载多态中同名的不同方法要求【形式参数个数或者类型不同】 Java中对象是一组域和方法的集合 Java程序可以分为两大类：Applet 和Application JVM把字节码程序与各种不同的操作系统和硬件分开，使Java程序独立于平台。 简单数据类型Java中的数据类型： |- 简单数据类型 |-数值型 |- 整形 byte->short->int->long |- 浮点型 float、double |-布尔型 boolean |-字符型 char |- 复杂数据类型 |- 接口（interface） |- 数组 |- 类（class） 标识符的命名 以字母、下划线（_）、数字、美元符号（$） 不限字符个数 区分大小写 变量使程序中最基本的存储单元。 Java语言中的简单数据类型|类型|意义|默认初始值|长度（位）||–|–|–|–|*|boolean|布尔值|false|1||char|Unicode字符|\u0000|16||byte|有符号整数|0|8||short|有符号整数|0|16||int|有符号整数|0|32||long|有符号整数|0L|64||float|浮点数|0.0F|32||double|浮点数|0.0D|64| 整型常量：十进制、八进制和十六进制整数。对于long类型常量要在后面加上L或l 整形变量分为4中：byte\short\int\long 浮点数据数据：float类型和double类型 float类型占内存少运算快 double类型精确度高 字符串变量只有一种：char类型。 char类型的数值可以转换成int类型 int转换成char需要强制转换 在Java中，所有的数据类型的长度均为固定值，没有sizeof保留字。 char是16位Unicode字符 实型变量在运算中不会产生溢出的问题。 byte类型的范围：【-128-127】 char类型的范围：【0-65535】 简单数据类型 局部变量在使用之前必须初始化否则编译错误 类的成员变量则不一定初始化，系统使用默认的初始值 编译时出现错误，不能将double类型转换为float类型数据。float类型数据比double类型数据长度小。 char类型数据可以自动转换为除了Boolean类型数据之外的任何类型的数据。 浮点数做除法时，如果分母为0.0，则不会出现溢出，系统默认的结果为NaN特殊值。 boolean只有true和false两个值，不能做类型转换包括自动和强制。 char类型数据是由单引号括起来的Unicode字符或转义字符 float类型在运算中如果出现下溢，则系统将结果设置为0.0；上溢为+-Infinity（无穷大） 用整形10创建一个Integer类的对象 Integer i = new Integer(10); Java中占存储空间最少的是boolean，该类型数据占用存储空间1位。 定义浮点型float值：【float f = 2222.111f】 浮点型数据属于实型数据 浮点型数据由数字和小数组成 浮点型数据包括实型常量和实型变量 length是合法的Java保留字。 \r回车 int只能自定转换成long、float、double类型 NaN 无符号整数类型不是Java数据类型 ‘\t’是一个正确的字符常量。 常数NaN被放在java.lang.Double中]]></content>
      <categories>
        <category>二级Java</category>
      </categories>
      <tags>
        <tag>二级Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL Server复习]]></title>
    <url>%2F2018%2F12%2F24%2FSQL-Server%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[复习一数据库文件和文件组 数据库的存储结构 逻辑存储结构：数据库由哪些信息所组成。（SQL Server数据库是由表、视图、索引等不同的数据库对象所组成）。 物理存储结构：如何在磁盘上存储数据库文件的（数据库在磁盘上以文件（数据文件和事务日志文件）为单位存储的。 一个数据库至少应该包含一个主数据文件和一个事务日志文件 SQL Server中数据文件分为3类： 数据文件 主数据文件（PRIMARY)— 存放数据 .mdf 次数据文件（SECONDARY)— 将数据分散存储到磁盘上 .ndf 事务日志文件（TRANSACTION LOG)— 存放事务日志 .ldf]]></content>
      <categories>
        <category>SQL Server复习</category>
      </categories>
      <tags>
        <tag>SQL Server复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程-数据库基础知识]]></title>
    <url>%2F2018%2F12%2F23%2F%E7%A8%8B-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[数据库基础知识基本概念数据库系统 数据：描述事务的符号记录（多种表现形式：文字、图形、图像、声音和语言） 数据库系统（DataBase System，DBS）：数据库、硬件、软件和人员4个部分组成 1. 数据库（DataBase） DB：长期存储在计算机内、有组织、可共享的数据集合。数据库中的数据按一定的数学模型组织、描述和存储，具有较小的冗余度，较高的数据独立性和易扩展性，并可被各类用户共享。 2. 硬件 硬件是计算机系统中的各种物理设备。（eg：存储数据所需要的外部设备。硬件的配置应满足整个数据库系统的需要） 3. 软件 软件包括操作系统、数据库管理系统（Database Manangement System）以及应用程序。DBMS是数据库系统中的核心软件，需要早操作系统的支持下工作。 4. 人员 系统分析员和数据库设计人员、应用程序员、最终用户和数据库管理员 数据库管理技术的发展 人工管理阶段 文件系统阶段 数据库系统阶段 BigDataBig Data产生的背景如下主要的4个方面： 数据来源和承载方式的变革。（物联网、云计算、移动互联网）等新技术的发展。 全球数据量出现爆炸式增长。（视频监控、智能终端、网络商店） 大数据已经称为一种自然资源 大数据日益重要 数据模型基本概念 模型是对显示世界特征的模拟和抽象。 数据模型是对现实世界数据特征的抽象 常用的数据模型： 概念数据模型 基本数据模型概念数据模型（信息模型） 按用户观点对数据和信息建模，是现实世界到信息世界的第一层抽象。（用户和数据库设计员交流的语言。） 基本数据模型按计算机系统的观点对数据建模，是现实世界数据特征的抽象，用于DBMS的实现。基本的数据模型有层次模型、网状模型、关系模型和面向对象模型 现实世界 —&gt; 信息世界 —&gt; 机器世界 数据模型的三要素 数据模型的三要素： 数据结构 数据操作 数据的约束条件]]></content>
      <categories>
        <category>数据库基础知识</category>
      </categories>
      <tags>
        <tag>数据库基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程-计算机基础知识]]></title>
    <url>%2F2018%2F12%2F23%2F%E7%A8%8B-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[计算机系统基础知识计算机系统的基本组成 计算机系统： |-硬件系统 |- 主机 |- CPU（运算器、控制器） |- 内存存储器（主存储器） |- 外部设备 |- 输入设备 |- 输出设备 |- 外存储器（辅助存储器） |-软件系统 |- 系统软件 |- 应用软件 计算机系统的硬件组成： 基本的计算机的硬件系统（5）： 运算器、控制器、存储器、输入设备和输出设备 计算机软件 计算机软件：管理、运行、维护以及应用计算机系统所开发的程序和相关文档的集合。（计算机系统中仅有硬件系统，则只是具备了计算的基础，并不能真正运算，只有将解决问题的步骤编制成程序并加载到计算机内存开始运行，才能完成运算） 计算机类型 类别 描述 体积和工作能力 巨型机、大型机、小型机和微型机 功能是否专一 通用计算机和专用（嵌入式）计算机 CPU的指令系统架构 复杂指令系统计算机和精简指令系统计算机 计算机中数据的表示 在计算机内部，数值、文字、声音、图形图像等各种信息都必须经过数字化编码之后才能被传送、存储和处理。]]></content>
      <categories>
        <category>《程序员教程》笔记---计算机基础知识</category>
      </categories>
      <tags>
        <tag>《程序员教程》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件测试基础知识点01]]></title>
    <url>%2F2018%2F12%2F22%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[软件测试试题 面向对象软件测试的白盒测试不能不加改变地照搬传统软件的白盒测试准则 从测试阶段角度，测试结束的正确顺序： 单元测试 -&gt; 集成测试 -&gt; 系统测试 -&gt; 确认测试 用于数据库恢复的重要文件是：日志文件 属于白盒测试方法：条件覆盖 有一组测试用例，它使被测程序中的每一个分支至少执行一次，它满足的覆盖标准是：判定覆盖 alpha测试需要用户代表参加是验收测试的一种 属于动态分析的是： 系统压力测试 程序数据流分析 划分软件测试属于白盒测试还是黑盒测试的依据是：是否能看到被测原程序 从E-R模型向关系模型转换时，一个M:N联系转换为关系模式时，该关系模式的主键为：M端实体的码与N端实体的码的组合。 事务Transaction是一个：操作序列 层次模型不能直接表示： m:n关系 属于黑盒测试方法的 测试用例覆盖 输入覆盖 输出覆盖 SQL语言中，删除一个表的命令是DELETE ❌ 单元测试通常应该先进行“人工走查”，在以白盒为主，辅以黑盒法进行动态测试 ✔ 数据的逻辑独立性：模式改变，外模式和应用程序不变 ✔ 逻辑设计可以独立于数据库管理系统 ❌ 好的测试员不懈追求完美 ✔ 数据库中的数据表可以有多个主键 ❌ 实体完整性规则：关系中主键不允许有空格 ✔ 如果事务T获得了数据项Q上的排他锁，则T对Q只能读不能写。 ✔ 在SELECT语句中，可以将查询结果直接存放在一个新表中。 ✔ 数据库恢复的基础是利用转储的冗余数据。 ✔ 测试后程序残存的错误数目中与该程序中已经发现的错误数目或检错率成正比。 ✔ 代码评审是检查源代码是否达到模块设计的要求 ❌ 在数据库设计中，将E-R图转换成关系数据模型的过程属于逻辑设计阶段 ✔ E-R图就是数据库的逻辑模型 ❌ SELECT语句查询条件中“!=ALL”与运算符 not in 等价 在E-R模型中 菱形框：联系 椭圆形：属性 矩形：实体 数据库中的索引有两种类型： 聚集索引 非聚集索引 数据库保护包括： 安全性保护 完整性保护 并发控制 故障恢复 层次和网状数据库操作的处理单位是： 记录。 关系数据库数据操作的处理单位是：关系 当关系R和S自然连接时，会自动去掉重复的列 ✔ 在SELECT语句中，当使用order by子句时，一定要使用group by子句。 ❌❌❌ 层次模型不能直接表示 多对多关系。 ✔ 在数据库技术中，尚未提交的随后又被撤销的数据被称为冗余数据。 ❌ 相对于非关系模型，关系数据模型的缺点之一是：数据结构简单。 ❌ 软件测试主要有白盒测试、黑盒测试、灰盒测试、手工测试、自动化测试、静态测试等7种测试方法 数据独立性 逻辑数据独立性 物理数据独立性 数据库保护： 安全性保护 完整性保护 并发控制 故障恢复 SQL语句，用于授权的命令是：grant SQL语言分为：DML、DDL、DCL、DQL 从数据库管理系统的角度划分数据库的体系结构，可分为三层： 外模式 模式 内模式 软件验收测试：α测试、β测试、UAT测试 二维表种的列和行在关系模型中分别称为：属性、元祖 查询不仅可以重组表中的数据，还可以修改数据。 ❌ 触发器可以在程序中被调用执行 ❌ Web网站测试需要考虑数据库测试 ✔ 没有可运行的程序，我无法进行测试工作 ❌ 相对于非关系模型，关系数据模型的缺点之一是数据结构简单 ❌ 验收测试是以用户为主导的测试 数据库后备副本的用途是：故障后的恢复 软件测试设计活动主要有： 工作量分析 确定并说明测试用例 确立并结构化测试过程 复审并评估测试覆盖 TCP/IP模型中传输层协议：TCP和UDP 典型的瀑布模型的四个阶段： 分析 设计 编码 测试 Beta测试是验收测试的一种 ✔ 测试需求一定要写的很细很细 ✔ 在数据库设计中，将E-R图转换关系数据模型的过程属于逻辑设计阶段 ✔ 测试用例一般由测试设计人员写的 ✔ 当两个关系没有公共属性时，其自然连接操作结果集为空集 ❌ 验收测试的测试用例主要根据需求分析的结果来设计。 改变文件所有者的命令为：cat 健壮性等价类测试的测试用例要求在有效等价类中取值。 如果互联的局域网高层分别采用TCP/IP协议与SPX/IPX协议，可以选择的互联设备应该是：路由器 驱动模块模拟的是：主程序 OSI模型中通过产生并检测电压来发送和接受数据信号的是物理层 OSI模型中用于端到端数据传输的是传输层 数据库设计前只需要数据库分析设计人员 ❌ 在表或视图上执行INSERT、UPDATE、DELETE语句可以激活触发器 ✔ 发现错误是软件测试的唯一目的。 ❌ SQL语言中，删除一个表的命令是DELETE ❌ 软件测试等于程序测试 ❌ 满足1NF的关系消除了属性之间的传递依赖 ❌ 测试用例一般是由测试设计人员写的 √ 软件质量管理（QM）应有质量保证（QA）和质量控制（QC）组成属于QC的是： 测试 跟踪 监督 逻辑覆盖方法： 组合覆盖 判定覆盖 条件覆盖 接口覆盖不属于逻辑覆盖的方法 条件覆盖的目的是：使程序中的每个判定中每个条件的可能值至少满足一次。 一程序中所含有的路径数与程序的复杂度有着直接的关系 动态黑盒子测试： 直接测试底层功能、过程、子程序和库 在自低向上测试中，要编写称为测试驱动模块来测验正在测试的模块。 准确度和精确度高不是自动化测试的优点 软件测试主要分为：单元测试、集成测试、系统测试、验收测试等四类。 软件缺陷产生的原因包括需求、设计、编码以及其他原因 对面向过程的系统采用的集成策略自顶向下集成、自定向上集成两种。 黑盒测试用例设计方法包括等价类划分、边界值分析、以及因果图，错误推测法等。 软件开发模式： 大棒模式 边写边改模式 流水模式 螺旋模式 黑盒测试用例设计方法包括等价类划分法、边界值法以及因果图法、错误推测法等 测试过程中，测试计划用于描述测试的整体方案，缺陷报告描述依据测试案例找出的问题。 传统的等价类划分测试的实现分为两步进行： 划分等价类表 设计相应的测试用例 在兼容性测试中，向前兼容是指可以使用软件的以前版本，向后兼容是指可以使用软件的未来版本 不需要修复软件缺陷的原因包括 没有时间 不能算真正的软件缺陷 风险太大 不值得修复 动态测试的两个基本要素 被测试程序 测试数据 在软件底层进行的测试称为：单元测试 在确定黑盒测试策略时，优先选用的方法时：等价类划分 测试人员主观认为不合理的地方不属于软件缺陷 产品发布后修复软件缺陷比项目开发早期这样的费用要高：100倍或更高 灰盒测试把黑盒测试和白盒测试的界限打乱了 软件测试的目的是尽可能多的找出软件地缺陷。 ✔ Beta测试是验收测试的一种。 ✔ 验收测试是由最终用户来实施的。 ❌ 项目立项前测试人员不需要提交任何工作 ✔ 单元测试能发现约80%的软件缺陷 ✔ 代码审查是检查源代码是否达到模块设计的要求。 ❌ 自低向上集成需要测试员编写驱动程序 ✔ 负载测试是验证要检验的系统的能力最高能达到什么程序。 ❌ 测试人员要坚持原则，缺陷未修复完坚决不予通过。 ❌ 代码评审员一般由测试员担任 ❌ 根据IEEE对软件测试做出的定义，软件测试主要体现在评错和度量两个方面 单元测试的类型主要分为： 逻辑单元测试 集成单元测试 功能单元测试 软件缺陷产生的原因包括： 软件说明书 设计 编写代码 测试过程中，测试计划用于描述测试的整体方案， 缺陷报告描述依据测试案例找出的问题。 传统的等价类划分测试的实现分两步进行： 划分等价类表 设计相应的测试用例 白盒测试的条件覆盖标准强于判定覆盖 ❌ 软件是包括 程序、数据、相关文档的完整集合 硬件与软件的最大区别:软件产品是逻辑产品，硬件产品是物质产品 计算机软件和计算机硬件构成了完整的计算机系统 软件的逻辑模型是形成于需求分析阶段 边界值分析法属于 黑盒测试方法 白盒和黑盒最大的不同在于：测试的任务不同 使用白盒测试方法时，确定测试数据应根据程序的内部逻辑和指定覆盖标准 单元测试一般以白盒法为主，测试的依据是程序内部逻辑规格说明 编码阶段产生的错误由单元测试检查出来 关键词 描述 单元测试 详细设计说明书，测试程序代码 集成测试 静态测试说明书，测试软件结构 确认测试 需求说明书为指导 代码复审属于静态测试（人工测试），不实际运行程序 动态测试分为黑盒测试法，白盒测试法 边界值分析法属于黑盒测试法 逻辑覆盖属于白盒测试法 语句覆盖 分支覆盖 条件覆盖 条件组合覆盖 路径覆盖 软件测试是按照特定的规程，发现软件错误的过程。 测试用例是专门为了发现软件错误而设计的一组或多组数据，它由测试输入和预期的输出数据组成 测试过程的三个测试阶段的主要📕 需求规格说明书 概要设计 详细设计 实际的逻辑覆盖测试一般以条件组合为主设计测试用例 发现错误能力最弱的覆盖准则是： 语句覆盖 单元测试所使用的主要测试方法： 白盒测试 对于软件缺陷的修复费用，在分析阶段的花费最小 集成测试所使用的主要测试方法： 黑盒测试 对于一些关键代码或新人写的代码，主要采取的会议审查 当程序有修改，必须要求保证原有功能正常的情况下，采用回归测试 驱动程序，可以被模拟被测试的上级模块 性能测试： 时间性能 和 空间性能 验收测试：α测试和β测试 自顶向下测试有两种组合策略：深度优先策略和广度优先策略 系统流程图用于可行性分析中的当前运行系统描述 系统流程图是描述物理系统的工具 DFD工具在软件详细设计过程中不采用 程序的三种基本结构的共同特点是：只有一个入口和一个出口 复习一 测试计划编写要六个要素： 1. what 2. why 3. when 4. where 5. who 6. how 测试用例由【输入数据】和预期的【输出数据】两部分组成 性能测试主要包括两个方面【时间性能】和【空间性能】 验收测试主要包括两方面内容【α测试】和【β测试】 自顶向下测试有两种组合策略【深度优先策略】和【广度优先策略】 测试计划的指定必须要注意： 测试策略 测试范围 测试方法 测试安排 测试风险 测试管理 制定测试计划的步骤： 确定测试范围、确定测试策略、确定测试标准、确定测试架构、确定项目管理机制、预计测试工作量、测试计划评审 软件测试用例主要由【测试输入数据】和【测试的预期结果】两部分组成 设计测试用例相关的文档是： 项目开发计划 需求规格说明书 软件设计说明书 在设计测试用例时，等价类划分是用得最多的一种黑盒测试方法 黑盒测试方法的优点可发现实现功能需求种的错误 软件测试项目周期： 需求阶段 测试计划 阶段测试 设计阶段测试 执行阶段 软件测试过程模型有： V、H、W、X 负载测试属于：性能测试 Loadrunner主要用来做性能测试 项目立项前测试人员不需要提交任何工作 Beta测试是验收测试的一种 验收测试是由最终用户来实施的 不存在质量很高且可靠性很差的产品 复习二 软件测试主要分为：单元测试、综合测试、确认测试、系统测试四类测试。 软件缺陷产生的原因： 编写说明书 设计 编写代码 等 黑盒测试用例设计方法： 1.等价类划分 2.边界值分析法 3.因果图法 4.错误推测法 测试的过程： 测试计划用于描述测试的整体方案。 缺陷报告描述依据测试案例找出的问题。 传统的等价类划分测试的实现两步进行： 划分等价类表 设计相应的测试用例 在兼容性测试中 向前兼容指可以使用软件的以前版本 向后兼容指可以使用软件的未来版本 白盒测试：结果测试或逻辑驱动测试。 黑盒测试：功能测试或数据驱动测试或基于规格说明书的测试。 动态测试的两个基本要素是：被测试程序、测试数据（测试用例） 🌫复习三 软件测试按照测试层次可分为：单元测试、集成测试和系统测试 软件测试是采用测试用例执行软件的活动。 软件测试是软件开发过程中的重要手段，是软件指令保证的重要手段。软件测试的主要任务： 预防软件发生错误 发现程序错误 提供诊断错误信息 导致软件缺陷的最大原因： 软件需求说明书 测试用例是为达到最佳的测试效果或高效的揭露隐藏的错误而精心设计的少量测试数据，至少包括： 测试输入 执行条件 预期的结束 软件缺陷修复的最高阶段为：发布阶段 产品的异常情况是关于软件缺陷的描述 N-S图，至少需要16个测试用例完成逻辑覆盖。 边界值分析法设计出的测试用例发现程序错误的方法最强。 功能测试是根据软件的规格说明来设计测试用例。 在软件修改之后，再次运行一千为发现错误而执行程曾用过的测试用例，这种测试称之为：回归测试 因果图法是根据输出对输入的依赖关系来设计测试用例的。 测试工程师的工作范围包括检视代码、评审开发文档属于静态测试 对于一个含有n个变量的程序，采用基本边界值分析法测试程序会产生4n+1个测试用例。 关于测试用例特征： 最有可能抓住错误的 一组相似测试用例中最有效的 既不是简单，也不是太复杂 数据流测试是一种关注变量定义赋值点（语句）和引用或使用这些值得点（语句）的结构性测试，主要用作路径测试的真实姓检查。 单元测试属于动态测试验收测试是以最终用户为主的测试没有发现错误的测试是没有价值的 软件测试工程师的一些工作。 监视代码、评审开发文档（静态测试方法） 进行测试设计、写作测试文档（测试计划、测试方案、测试用例） 执行测试、发现软件缺陷、提交缺陷报告、并确认缺陷最终得到了修正 复习四 软件测试的工作量占整个软件开发工作量的 70% 软件的六大质量特性包括： 功能性 可靠性 可用性 效率 可维护 可移植 等价类划分方法设计测试用例的描述： 如果等价类中的一个测试用例能够捕获一个缺陷，则选择该等价类中的其他测试用例也能捕获该缺陷 正确而地划分等价类，可以大大减少测试用例的数量，测试会更加准确有效3. 等价类划分方法常常需要和边界值分析法结合使用× 若某个输入条件是一个布尔量，则无法确定有效等价类和无效等价类 白盒测试侧重于程序结构。黑盒测试侧重于功能 功能（黑盒）测试的方法： 等价类划分法 边界值分析法 基于决策表的测试 针对是否对无效数据进行测试，可以将等价类测试分为： 标准（一般）等价类测试 健壮等价类测试 在设计测试用例时，【等价类划分】是用得最多的一种黑盒测试方法 用等价类划分法设计8位长数字类型用户名登录操作的测试用例，可以分成4份。 常用的黑盒测试方法有边值分析、等价类划分、错误猜测、因果图等。其中（边值分析）经常与其他方法结合起来使用。 用边界值分析法，假定X为整数，10&lt;= x &lt;= 100,则X在测试中应该取（x=9,x=10,x=100,x=101）边界值 在用白盒测试中的逻辑覆盖法设计测试用例时，有语句覆盖、分支覆盖、条件覆盖、条件/判定覆盖、条件组合覆盖和路径覆盖中，其中【路径覆盖】时最强的覆盖准则 实际的逻辑覆盖测试中，一般以条件组合覆盖为主设计测试用例 使用白盒测试方法时，确定测试数据应根据【程序内部逻辑】和【指定的覆盖标准】 逻辑覆盖方法： 组合覆盖 判定覆盖 条件覆盖接口覆盖不属于逻辑覆盖方法 条件/判定覆盖是设计足够多的测试用例，使得程序中每个判定包含的每个条件的所有情况。（真/假）至少出现一次，并且每个判定本身的判定结果（真/假）也至少出现一次。 在进行单元测试时常用的方法：【采用白盒测试，辅之以黑盒测试。】 单元测试的描述： 单元测试的主要目的时针对编码过程中可能存在的各种错误 单元测试一般是由程序开发人员完成的 单元测试属于白盒测试的一种方法 单元测试是一种不需要关注程序结构的测试 ❌ 单元测试将根据在【详细设计】阶段中产生的规格说明进行 单元测试的依据：【模块功能规格说明】 软件测试是软件质量保证的重要手段，【单元测试】是软件测试的最基础环节21.JUnit描述 JUnit是Java语言的单元测试框架 JUnit推荐先测试后实现的方法 setUp和tearDown函数只执行一次JUnit只能测试公共函数 ❌ JUnit中，testXxxx()方法就是一个测试用例，测试方法是：public void testXxxx() 划分软件测试属于白盒测试还是黑盒测试的依据是：【是否执行程序代码】 正确： 测试不能证明软件的正确性 测试员需要良好的沟通技巧 QA与Testing属于一个层次的概念（❌） 成功测试时发现了错误的测试 属于界面元素测试： 窗口测试 文字测试 功能点测试 不属于界面元素测试：鼠标测试 对Web网站进行的测试中属于功能测试的是：连接速度测试 使用软件测试工具的目的是：更好的协助开发工具 基本路径测试：白盒测试 通过疲劳强度测试，最容易发现【内存泄漏问题】 在性能测试中关于数据准备： 识别数据状态验证测试案例 初始数据提供了基线是用来评估测试执行的结果 业务数据提供负载压力背景 脚本中真实模拟负载 功能测试工具：WinRunner 测试工程师一般采用负载压力作为测试工具 Web应用系统复杂压力测试中属于衡量业务执行效率的指标： 并发请求数 每秒访问量 交易执行实践响应时间 交易执行吞吐量 并不是 衡量业务执行效率的指标。]]></content>
      <categories>
        <category>软件测试期末复习</category>
      </categories>
      <tags>
        <tag>软件测试期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Artificial Intelligence]]></title>
    <url>%2F2018%2F12%2F21%2FArtificial-Intelligence%2F</url>
    <content type="text"><![CDATA[中国大学Imooc·人工智能实践：TensorFlow个人学习笔记什么是人工智能？ 人工智能：机器模拟人的意识和思维 Artificial Intelligence 原点 * **人工智能之父**------------- **Alan Mathison Turing** 图灵（1912-19954） * 1950提出：《机器能思考吗？》 ----- **图灵测试** ：一种用于判定机器是否具有智能的实验方法（30%） * 2014年 首台通过图灵测试的计算机出现 * 生活的示例：**微软Cortana**、**苹果Siri** 什么是机器学习？机器学习是一种统计学方法，计算机利用已有的数据，得出某种模型，在利用此模型预测结果 * 传统的**冯诺依曼计算机**工作原理：**指令和数据都被预先存储好，按照指令先后顺序逐条读取并运行。** * 机器学习作为一种统计学方法利用现有的数据得出某种模型利用此模型预测结果（随经验的增加效果会变好） 新数据 --Input--> 模型（历史数据 进行训练）--Predict--> 结果 什么是深度学习（神经网络）？ 对连续数据的预测和对离散数据的分类 输入1 (权值1) 输入2 （权值2）-----------------> 【求和】 --非线性函数--> 输出 输入3 （权值3） ----神经元模型 机器学习的应用领域 计算机视觉 语音识别 自然语言处理]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的英语单词]]></title>
    <url>%2F2018%2F12%2F21%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[单词 讲解 studio n.工作室、演播室、画室 film studio电影制片长 photo studio 照相馆]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语单词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode IDE学习]]></title>
    <url>%2F2018%2F12%2F21%2FVSCode-IDE%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[VSCode 常用的快捷键 keywords Function ! + tab 自动生成HTML5模板 Alt + Shift + F 格式化代码]]></content>
      <categories>
        <category>VSCode</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript知识点]]></title>
    <url>%2F2018%2F12%2F21%2FJavaScript%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[复习一 JS中写“Hello World”方法：document.write(“Hello World”); JS特性： 解释性 用于客户端脚本语言 基于对象 产生一个包含0-7之间的随机整数：Math.floor(Math.random() * 8); 产生当前日期的方法：Date()```123456789101112135. 动态改变网页标题：`document.title=(&quot;新标题的内容&quot;);`6. (css)background-image = (style)backgroundImage7. history对象的`forward`用于加载历史列表的下一个URL页面8. 按钮不能与onChange事件处理程序相关联。9. window对象的status属性用来指定浏览器状态栏。10. 在JS中，可以使用Date对象的getDate()方法返回一个月中的每一天。11. 在JS中对Browser对象的层次关系逻辑的理解 &lt;pre&gt; &lt;font color=blue&gt;window 对象是所有页面内容的根对象&lt;/font&gt; &lt;font color=red&gt;document对象包含了form对象 &lt;/font&gt; &lt;/pre&gt;12. substring(9,13)第10个---&gt; 第14个（这里包括第14个）13. 隐藏标签： ` var sl = pareseInt(“101中学”); document.write(sl); ——&gt; 101 window的prompt()方法可以显示输入对话框 open()方法的scrollbars可以设置是否显示滚动条 当元素失去焦点时激发的时间：Blur DHTML：动态样式、动态内容、动态定位（无动态语法） screen可以获得屏幕的大小]]></content>
      <categories>
        <category>JavaScript知识点</category>
      </categories>
      <tags>
        <tag>JavaScript知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL---三级模式两级映射]]></title>
    <url>%2F2018%2F12%2F20%2FSQL-%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E4%B8%A4%E7%BA%A7%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[数据的三级模式 外模式（用户级） 用户所见到的数据的视图（数据库在用户👁眼中的反映） 概念模式(概念级) 数据库设计者综合所有用户的数据构造的全局数据结构 内模式（物理级） 数据库物理存储模式与方法 数据库系统的两级映射： 用户数据库 — 概念数据库 外模式 —&gt; 概念模式概念数据库 — 物理数据库 概念模式 —&gt; 内模式 概念模式（conceptual schema）:数据库中全部数据的整体逻辑结构的描述。 外模式（external schema）:用户与数据库系统的接口，是用户用到的那部分数据的描述。 内模式（internal schema）:数据库在物理存储方面的描述，定义所有内部记录类型、索引和文件的组织方式，以及数据控制方面的细节。 外模式／模式映象存在于外部级和概念级之间，用于定义外模式和概念模式之间的对应性。 模式／内模式映象存在于概念级和内部级之间，用于定义概念模式和内模式之间的对应性。 高度的数据独立性 数据独立性（data independence）是指应用程序和数据库的数据结构之间相互独立，不受影响。 数据独立性分成物理数据独立性和逻辑数据独立性两个级别。 (1)物理数据独立性：对内模式的修改尽量不影响逻辑模式、外模式和应用程序，我们称数据库达到了物理数据独立性（简称物理独立性）。 (2)逻辑数据独立性：对逻辑模式的修改尽量不影响外模式和应用程序，我们称数据库达到了物理数据独立性（简称逻辑独立性）。 数据抽象中各个层次中记录的联系]]></content>
      <categories>
        <category>SQL Server知识点</category>
      </categories>
      <tags>
        <tag>SQL Server知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL-Server知识点2]]></title>
    <url>%2F2018%2F12%2F20%2FSQL-Server%E7%9F%A5%E8%AF%86%E7%82%B92%2F</url>
    <content type="text"><![CDATA[复习三 在信息世界中能唯一标识实体的属性集称为: 码 如果关系模式R是1NF，且么个非主属性都完全函数依赖于主键，那么称R是第二范式的模式。 数据规范化的优点之一是 消除数据冗余 改进数据整体组织 增强数据的一致性 增加数据设计的灵活性 关系代数运算中，专门的关系操作有：选择、投影、除和连接 关系中属性的取值范围称为属性的域 在SQL Server2005中通配符只有在LIKE中才有意义 触发器也是一种存储过程，它主要通过事件进行触发而被执行，而存储过程可以通过存储过程名而被直接调用 使用GO命令来标识T-SQL批处理的结束 在索引命令中使用关键字CLUSTERED表示将建立的是聚集索引 数据库概念模型：独立于计算机硬件和DBMS ★★★ 学生表中st(学号、姓名、性别、年龄），删除其中年龄字段的sql语句是ALTER TABLE st DROP 年龄 SQL Server 2000的四个系统数据库中记录系统的所有信息：Master 有这样的一个数据表，职工（职工号、姓名、职务、工资），要想查询工资最高的职工号和姓名：SELECT 职工号,姓名 FROM 职工 WHERE 工资=（SELECT MAX（工资） FROM 职工） SQL语言具有数据操作功能，SQL语言的一次查询的结果是一个：表 视图增强了数据的安全性。 可以激活触发器的是（SELECT、UPDATE、DELETE）不能激活触发器的是（INSERT） 数据模型数据模型是对客户事务以及联系的数据描述，是概念模式的数据化，即数据模型提供表示和组织数据的方法 函数依赖某个属性集决定另一个属性集时，称另一属性集依赖于该属性集。 内模式内模式也称存储模式或物理模式，是对数据物理结构和存储方式的描述，是数据在数据库内部的表示方法，一个数据库只有一个内模式 触发器触发器是一种存储过程，它是一种在基本表被修改时自动执行的函数过程主要通过事件进行触发（UPDATE DELETE SELECT）而被执行。 锁锁是防止其他事务访问指定的资源、实现并发空值的一种手段，是多个用户能够同时操作同一个数据库中的数据而部发生数据不一致现象的重要保障。 复习四 SQL Server数据库文件有三类，其中主数据文件的后缀为：.mdf 视图是虚拟的表，观察到的数据是实际基本表中的数据。 字符型系统数据类型：char、varchar、text 索引顺序和数据表的物理顺序相同的索引是：聚集索引 数据库系统的构成： 数据库、硬件、数据库管理系统 数据库系统软件：DBMS和OS SQL语言不能自动实现关系数据库的规范化 外键不一定要与相应的主键同名。 数据库是计算机系统中一定的数据模型组织、结构化的数据的集合。 数据库设计 需求分析 概念结构设计 逻辑结构 物理结构设计 数据库实施 数据库运行和维护 概念设计的主要目标是产生数据库概念结构，该结构主要反映：企业的信息需求 数据和信息相互独立 实体只用于表示实际存在的事物 实体—联系：现实世界-&gt;数据世界-&gt;信息世界 DBA数据库管理员 ——- 删除表 DROP 实体之间的联系有3中 用树形结构表示实体类型以及实体间联系的数据模型称为层次模型 内模式映像为数据库提供了数据独立性 参照完整性是对外键的约束 选择 投影 连接 文件系统和数据库系统最大的区别在于 ：数据冗余 内模式是描述数据如何在存储介质上组织存储的。称之为模式 数据库逻辑设计的三步：分析、画E-R图、建立数据模型 数据独立 、 数据共享、 减少了数据冗余、数据的安全性、使用操作方便性 数据库的数据独立性包括：逻辑独立性和物理数据独立性 数据库结构设计的过程：概念设计 -&gt; 逻辑设计 -&gt; 物理设计 数据库管理：手工文档 -&gt; 文件系统 -&gt; 数据库管理 一个关系就是一个二维表 一行对应一个元祖 一列对应一个域（属性） DBA：数据库管理员维护和管理数据库 人工管理 -&gt; 文件管理 -&gt; 数据库管理 在关系数据库中，用二维表表示实体以及实体之间的关系。 数据冗余：数据集合中重复的数据。 数据库系统：数据库-&gt; 数据库管理系统 -&gt; 数据库管理员和应用程序组成。 数据的完整性：数据的正确性和有效性]]></content>
      <categories>
        <category>SQL Server知识点</category>
      </categories>
      <tags>
        <tag>SQL Server知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL Server知识点]]></title>
    <url>%2F2018%2F12%2F19%2FSQL-Server%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[复习一数据库的特点： 1.数据共享2.数据完整性3.数据独立性高 SQL Server中系统数据库：master、model、msdb DBMS的定义· DBMS是位于用户与操作系统之间的一层数据库管理软件，—&gt; 系统软件，它为用户或应用程序提供访问数据库的方法。对于数据库在建立、使用和维护时由其统一管理、统一控制 SQL的视图从基本表或视图中导出的 是sql数据库文件的后缀的是：.mdf.mdb.ndf 【a：65】 &amp; 【A：97】 SELECT round(13.4321,2) round(13.4567,3)执行结果：13.4300 和 13.4570 &lt;取n位小数、四舍五入 SQL Server 2008采用的身份验证模式：Windows身份验证模式和混合模式 触发器定义在一个表中，当表中执行insert、update、delete操作时被触发自动执行 SQL Server复制有快照复制、事务复制和合并复制3中类型 数据库概念设计概念设计的理论基础 概念设计是数据库系统设计的核心和基础 用什么来表示? 表示方法： E-R图（Entity-Relationship Diagram) 谁提出的? 时间： 1976年 P.P.S Chen 提出【数据库设计方法】 目的？ 在需求分析的基础上利用E-R图构造一个反映现实世界实体之间联系的企业模式。 结论：在DBS的设计中，建立反映客观信息的数据模型最为重要的 数据模型是连接客观信息世界和数据库系统逻辑组织的桥梁，开发人员和用户之间交流的共同基础121.数据是表达信息的一种重要的量化符号，是信息存在的一种重要形式。2.数据模型是数据特征的一种抽象。（数据的共性） 数据模型所包含的两个方面： 1 . 数据的静态特性： * 基本结构 * 数据间的关系 * 数据间相互约束的特性 2 . 数据的动态特性：主要包括对数据进行操作的方法。 （从E-R图中可以直观的看出E-R主要体现的是这一方面） E-R模型 E-R模型【实体（entity）-关系（relationship）模型】。——-&gt; 描述组织的概念模型 E-R图的三个组成部分 实体 ⬜ （对象） 关系 🔷 （对象之间的关系） 属性 ⚪ （对象的属性即表的中一个列） 问题： E-R模型转换为关系模型的规则： （1）实体类型的转换1将每个实体类型转换成一个关系模式，实体的属性即为关系的属性，实体标识符即为关系的键 （2）联系类型的转换 实体间联系是 1:1 1可以在两个实体类型转换成两个关系模式中的任意一个关系模式的属性加入另一个关系模式的键和联系类型的属性。 实体间联系是 1:N 1在N端实体类型转换成的关系模式中加入1端实体类型转换成的关系模式的键和连携类型的属性 实体间联系是M:N 1将联系类型转换成关系模式，其属性为两端实体类型的键加上联系类型的属性，而键位两端实体键的组合。 数据库的逻辑设计数据库规范化原则 规范化是数据库设计中一个重要过程，可以通过它来剔除数据库中冗余的数据。 范式是一组数据设计标准。（要想设计出一个结构合理的关系型数据库必须满足一定的范式） 第一范式（原子性【列】）第一范式式是最基本的范式，【数据库表中的所有字段值（列）都是不可分解的原子值】 第二范式（确保表中的每列都和主键相关）第二范式的两项要求： 所有表符合第一范式 表中每个非主键列都必须完全函数依赖于主键 完全函数指不能存在仅依赖主关键字一部分属性，否则这个属性和主关键字的一部分分离出来形成一个新的实体，新实体和原实体之间是一对多的关系。 第三范式（确保每列都和主键列直接相关，而不是间接相关）第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能简介相关。 遵守三种范式的作用： 减少数据冗余； 改进数据整体组织； 增强数据的一致性； 增加数据库设计的灵活性； 数据库的物理设计 物理设计是为逻辑数据模型建立一个完整的数据库结构，包括存储结构和存取方法。 数据库在物理设备上的存储结构与存取方法称为数据库的物理结构 物理设计的任务之一就是要确定选择那些存取方法。 常用的存取方法： 索引方法和聚簇（Cluster）方法 对物理结构进行评价，评价的依据是系统的时间和空间效率。 物理结构依赖于操作系统（OS）和数据库管理系统（DBMS） 复习二 SQL Server 保存着每个DB对象的信息的系统表：Sysobjects Alter不能出现在WHERE子句 age Between 30 and 40 等于 age &gt;= 30 and age &lt;= 40 限制某种数据的输入范围：check约束 记录DB事务操作信息的文件是：日志文件 SQL的聚集函数 COUNT、SUM、AVG、MAX、MIN**不允许出现在查询语言的WHERE子句之中**。 列值为空值（NULL）———&gt; 数值是未知📍的。 在sysdatabase中记录着存储过程中每个参数的信息。 √ 使用INSERT命令一次只能插入一行数据 ❌ DROP TABLE –&gt; 删除表 DROP VIEW –&gt; 删除表上的视图 —–&gt; 手工删除 DTS ： 数据传输服务 SQL—&gt; 验证模式【windows身份验证模式和混合模式】 单行注释语句： – 完整性约束 实体完整性 域完整性 参照完整性 用户定义完整性 SQL Server 提供单行注释 – SQL Server局部变量前面的字符为 @ 所谓的视图： 一张虚拟的表 在存储视图时存储的视图是定义 在存储视图时存储在视图中的数据 数据库系统的特点： 数据的结构化 数据共享 数据独立性 可控冗余 在SQL Server 2000中一个批处理语句是以GO结束的 在SQL Server 2000中的数据以页为基本存储单位，而8个相邻的页称为扩展盘区，那么扩展盘区大小应该为64kb 在SQL Server 2000中，索引的顺序和数据表的物理顺序不相同的索引是 非聚集索引 取数据的平均值的可以使用聚合函数是 AVG函数 游标的概念包括两个部分，它们是 游标结果集 和 游标位置 一个事务的操作必须具备以下四个属性： 原子性、隔离性、共享性、一致性和持久性 创建数据库语句 CREATE DATABASE 修改数据库语句 ALTER DATABASE 数据完整性，使用 约束是优先于使用触发器、规则和默认值。 声明一个长度为16的字符型变量“cname”，并赋初值为‘数据库系统概述’。 Declare cname char(16) set cname = ‘数据库系统概述’ Declare cname char(16) select cname = ‘数据库系统概述’; 在字符串中，我们应该怎样来产生一个回车并生成一个新行？ char(13) + char(10) 表student 表（学生表） 学号 姓名 性别 年龄 系别 1 吴好 男 18 计算机系 2 崔平 女 21 经管系 3 钱铀 女 19 电子系 course 表（课程表) 课程号 课程名 学分 1 SQL Server 4 2 数据接哦古 3 3 专业英语 2 sc表（选课表） 学号 课程号 成绩 1 1 88 2 1 90 2 2 70 3 3 79 1 . 把course表课程号为3的课程学分修改为3. UPDATE course SET 学分 = 2 WHERE 课程号 = 3 2 . 把student表中查询年龄大于18的学生的所有信息，并按学号降序排列。 SELECT * FROM student WHERE 年龄 > 18 ORDER BY 学号 DESC; 3 .（★★★）在以上三个表中查询选的课程“学分”为3，并且成绩大于80的学生的学号、姓名和性别。 SELECT DISTINCT student 学号,姓名,性别 FROM student,course,sc WHERE (student.学分=3) AND (course.课程号=sc.课程号） on student.学号 = sc.学号 WHERE(course.学分 = 3) AND （sc.成绩 > 80)]]></content>
      <categories>
        <category>SQL Server知识点</category>
      </categories>
      <tags>
        <tag>SQL Server知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWebCoreNote-- JavaScript&jQuery]]></title>
    <url>%2F2018%2F12%2F17%2FJavaWebCoreNote-JavaScript%26jQuery%2F</url>
    <content type="text"><![CDATA[JavaScriptJavaScript对象★★★ 定义：ECMA-262把对象定义为：”无序属性的集合，其属性可以包含基本值、对象或者函数”。 对象的几种定义格式： 12345678910111213141516// 第一种var person = new Object();person.name = &quot;Nicholas&quot;;person.sayName = function()&#123; alert(this.name);&#125;//调用方式：person.sayName();//第二种（对象字面量语法，较为流行）person = &#123; name: &quot;Nicholas&quot;, sayName: function()&#123; alert(this.name); &#125;&#125; JavaScript中的对象分为内建对象与宿主对象（抛开用户自定义对象不谈） 内建对象：JS语言本身包含的对象，eg：Marth、Array、Date等（JS的内建对象类似于Java就相当于Java的JDK）。 宿主对象：宿主对象不是由JS语言本身而是由它的运行环境提供的。具体到web应用。这个环境就是各种Web Browser。由Web浏览器提供的预定义对象被称为宿主对象。（类比Java，就相当于eclipse创建项目后引入Tomcat服务器的依赖jar包，eg：HttpServlet这些不属于JDK里面的类而是属于Tomcat依赖jar包中的类。 与宿主对象相关疑难点解释 在JS代码中，为什么获取一个标签对象后就可以通过对象”点”属性的方式获取该属性所对应的值？eg： 1234567&lt;script&gt; onload = function()&#123; var tt = document.getElementById("tt"); alert(tt.name + "," + tt.value + "," + tt.test);&#125;&lt;/script&gt;&lt;input type="text" id="tt" name="userName" values="zs" test="test"/&gt; 执行上面的代码弹出框会弹出username,zs,undefined,上述代码首先通过document.getElementById(“tt”)获取input标签所对应的js对象，然后通过对象”点”属性的方式(tt.name)取值，根据弹出框结果可以看出，name与value都是可以取出对应的值的，但是test却没有？ 解释：在web browser浏览器中，几乎对所有的HTML标签，都会对应着给他们预置JS对象，就是宿主对象，为了方便获取标签中的属性值，又在宿主对象中内置了常用属性，eg：input标签就有与其对应的js对象，该对象中预置了test、id、name、value等属性，所以用户可以通过对象点属性的方式去获取属性值，但是，该对象中并没有预置test属性，因此是无法通过对象点属性的方式获取其对应值的（可以通过tt.getAttribute(“test”)的方式获取）。 JS中常用的DOM元素操作★★★★★ var demo = document.getElementById(&quot;id&quot;); 根据标签中设置的id值来获取对应的标签对象，注意此处为Element，是“元素”的单数形式，因此获得的直接就是元素对象了，获取过之后可以直接通过demo”点”的方式获取属性值或绑定事件。 var demo = document.getElementsByClassName(“classname”); 根据标签中设置的class属性值来获取对应标签对象的集合数组，注意此处为Elements，是”元素”的 复数形式，因此直接获得的是一个数组，要想对标签对象进行操作，需要先遍历该数组取到标签对象后再操作。与相似的还有document.getElementByTagName(“tagname”)(根据标签名进行获取)、document.ElementByName(“name”)(根据name属性值获取) [元素对象.appendChild(元素对象)] 在一个元素标签对象内拼接一个子标签对象document.createElement(“”); 在JS中动态的创建一个标签对象，eg：document.createElement(“a”);创建一个a标签对象。 仅仅创建一个标签对象是无法在页面展示的，需要结合appendChind()方法将本地对象拼接与页面已经存在的标签对象产生关联才能做到在页面上展示。 通过remove方法删除某个标签对象。元素对象.remove(); var i = 元素对象.innerText 获取该标签及其该标签的后台标签内所有的文本内容。 元素对象.innerText 元素对象.innerText = “文本内容” 往当前标签内插入文本内容。 元素对象.innerHTML , var i = 元素对象.innerHTML获取该标签及其该标签的后台标签内所有的标签以及文本内容。元素对象.innerHTML = “标签文本内容” 往当前标签内插入标签以及文本内容。 事件绑定★★★★★ 🐖注意：对事件绑定的写法格式牢记于心，不可与后面的jQuery的写法混淆。 常用写法一：在HTML上进行事件绑定 function fn(){ alert("我被触发了！") } type1234567891011121314* 常用写法二：在JS中进行事件绑定```javascript&lt;script&gt; window.onload = function()&#123; var btn = document.getElementById(&quot;btn&quot;); btn.onclick = function()&#123; alert(&quot;我被触发了!&quot;): &#125; &#125;&lt;/script&gt; type123456789101112131415161718192021&gt; &gt; 注意：最容易出现的问题-------&gt;漏写✍文档加载事件**onload**```HTML&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; //错误示例❌ &lt;script&gt; var btn = document.getElementById(&quot;btn&quot;); btn.onclick = function()&#123; alert(&quot;我被触发了！&quot;); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;点我&quot; onclick=&quot;fn()&quot;/&gt; &lt;/body&gt;&lt;/html&gt; 错误分析🐬: 因为文档流是从上往下加载的，加载完第一行加载第二行，当加载到JS代码的时候执行JS代码，因为在此处JS代码块定义在了文档头标签``` 中，当程序执行``` var btn 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 ### 数据的两种遍历方式 * 对于非自己创建的js对象进行遍历时尽量使用普通for循环进行遍历。普通for循环只能遍历出角标为数字的值。 * 对于是自己创建的，既含有数字角标，又含有字符串角标的js对象进行遍历时使用增强for循环进行遍历。增强for循环既可以遍历出角标为数字的值也可以遍历出角标为字符串的值。 &lt;script type=&quot;text/javascript&quot;&gt; var arrs = new Array(4,8,90); arrs[&quot;first&quot;] = &quot;test1&quot;; arrs[&quot;second&quot;]=&quot;test2&quot;; //输出数组的长度 alert(arrs.length); //普通for循环进行数组的遍历 for(var i = 0; i &lt; arrs.length; i ++)&#123; alert(&quot;数组中角标为i的元素对应的值是：“ + arrs[i]); &#125; //增强for循环进行数组的遍历 for(i in arrs)&#123; alert(&quot;数组中角标为i的元素对应的值是: &quot; + arrs[i]); &#125; &lt;/script&gt;### 前端遇到BUG的处理思路★★★★★★&gt; * 核心步骤总结：三步走加两明确&gt;&gt; * 前端问题的一般体现：预期结果与实际不相符&gt; * 第一步：F12打开调试界面看是否有报错&gt; * 第二步：若调式界面中无错误信息，则调试相关函数，查看函数是否真的被调用了，如点击事件调用的函数。如何测试相关函数？在函数的第一行添加一个alert()或者console.log()。&gt; * 第三步：若函数也确实被调用，但预期结果与实际不相符，则代码逻辑问题。# jQuery&gt; 学习jQuery一定要清除jQuery对象和JS原声对象两者到底存在什么样的关系，不能将两者混淆，找到两者的区别。### JS原生对象与jQuery对象的转换★★★★★★```HTML&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;这是一个按钮&quot;/&gt;&lt;input type=&quot;text&quot; class=&quot;tt&quot; value=&quot;文本输入框1&quot;/&gt;&lt;input type=&quot;text&quot; class=&quot;tt&quot; value=&quot;文本输入框2&quot;/&gt;&lt;input type=&quot;text&quot; class=&quot;tt&quot; value=&quot;文本输入框3&quot;/&gt;&lt;input type=&quot;text&quot; class=&quot;tt&quot; value=&quot;文本输入框4&quot;/&gt; JavaScript： 通过id获取一个对象的对象那个 var btn = document.getElementById(“btn”); 获取之后即为一个对应元素对象，可以直接通过btn.value获取该对象中对应的value值。 JS元素对象转jQuery对象: $(btn) 绑定事件：btn.onclick = function(){} 通过class获取多个对应的对象 var tt = document.getElementsByClassName(“tt”); 获取之后为一个数组对象，需要通过遍历获取其中的每个元素对象，之后才能获取该对象中对应的value值。 JavaScript元素对象转jQuery对象：$(tt)。 绑定事件: 必须先遍历，之后再绑定。 jQuery: 通过id获取一个对应的jQuery对象 var btn = $(“#btn”); 获取之后为一个jQuery对象，要想获取该对象中的value值，那么就应该用对应的jQuery方法进行获取，即$(“#btn”).val()。 jQuery对象转JavaScript元素对象：$(“#btn”)[0] 绑定事件：$(“#btn”).click(function(){}) 通过class选择器获取一个对应的jQuery对象 var tt = $$(“.tt”); 获取之后为一个jQuery对象，而这个jQuery对象中包含多个原生JS元素对象，若是直接使用var tt = $(”.tt”).val(),那么只能获取一个元素对应的value值，若是要获取所有的value值，必须要对该jQuery对象进行遍历获取每个对象后再获取其value值。但是若是对这一组元素进行事件的绑定时，直接采用tt.click(function(){})绑定即可，不需要遍历获取每个元素后再进行绑定。 jQuery对象转JS元素对象：$(“.tt”).each(function(){alert(this.value)}). 绑定事件：$(“.tt”).click(function(){}) 可进行事件的批量绑定。 this与jQuery之间的关系★★★★12345678910111213&lt;script src="../jquery-1.11.3.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function()&#123; $(".tt").click(function()&#123; alert(this.value); &#125;); &#125;);&lt;/script&gt;&lt;input type="button" id="btn" value="这是一个按钮"/&gt;&lt;input type="text" class="tt" value="文本输入框1"/&gt;&lt;input type="text" class="tt" value="文本输入框2"/&gt;&lt;input type="text" class="tt" value="文本输入框3"/&gt;&lt;input type="text" class="tt" value="文本输入框4"/&gt; 在上面代码的事件绑定中this与当前jQuery对象的关系？ 通过上述代码，可以实现对含有类名为tt的元素对象进行点击事件的绑定，但是绑定后函数的执行是在点击事件发生的才执行，当点击时，点击哪个元素节点那么this就代表哪个元素对象。 谁调用函数，那么this就代表谁在此处任然使用。 jQuery 必会API 其他注意实现★★★★★ JS中进行字符串内容比较时，直接用==进行比较即可，JS中没有equals()方法！ JS中可以用Location.href=”url”的方式进行跳转链接🔗，当程序走到这里就会自动进行链接跳转。 关于对一个标签绑定多个相同事件的状况分析。 在标签中直接绑定两个相同的事件，那么每次执行的时候只会执行第一个绑定的事件 用原生js的方式对一个标签同时绑定两个相同的事件，后绑定的事件始终会覆盖先绑定的事件（先绑定的事件中的方法是不会执行的） 用jQuery的方式对一个标签同时绑定两个相同的事件，那么按照绑定事件的先后顺序去执行方法。]]></content>
      <categories>
        <category>JavaWebCoreNote</category>
      </categories>
      <tags>
        <tag>JavaWebCoreNote</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWebCoreNote--HTML&CSS]]></title>
    <url>%2F2018%2F12%2F16%2FJavaWebCoreNote-HTML-CSS%2F</url>
    <content type="text"><![CDATA[HTML核心知识点表单相关标签★★★★★form表单标签 写法：&lt;form&gt;&lt;/form&gt; 作用：为了将用户通过浏览器输入的数据提交到服务器 &lt;form&gt;标签所包含的重点属性: action、method、enctype action:指定数据需要提交到服务器路径 method:指定数据提交的方式，GET|POST enctype:一般在做文件上传的时候用，设置enctype=”multipart/form-data” 表单提交的工作机制：通过在form标签下设置表单相关标签的name属性，再通过用户输入或者选择自动的给标签设置value属性，在用户点击提交按钮或者用Ajax的方式提交数据时，将数据以key=value&amp;key=v1,v2…的形式传到服务器 input标签 写法：&lt;input&gt;&lt;/input&gt; 作用：为用户提供输入数据的空间 &lt;input&gt;所包含的重点属性：type、name、value name属性：元素名，如果需要表单数据提交到服务器，必须提供name属性值，服务器通过属性值获取用户提交的数据。 value属性：设置input标签的默认值。若为输入框，则当数据提交时value对应用户输入的内容 type属性包含8种重要属性值 text:文本框，单行输入的字段，用户可在其中输入文本，若input标签不设置type默认为text属性。 password:密码框，密码字段，用户输入的数据以黑·标识。 radio：单选框，表示一组互斥选项按钮中的一个。当一个按钮被选中，之前选中的按钮就变为非选中的。 checkbox：复选框，用户可以一次选择多个。 submit：提交按钮。点击此按钮就会把表单数据发送到服务器。 button：普通按钮，经常与JS结合使用。 file：文件上传组件，提供”浏览“按下可以选择需要上传的文件。 hidden：隐藏字段，数据发送给服务器，但浏览器不进行显示。 input标签重点属性学习 name属性（除了submit提交按钮，在其他标签标签上都应该有加上name属性的好习惯） name属性是表单提交中最重要的属性，如果没有此属性则用户提交的任何信息，服务器都无法取得造成数据的丢失。 //错误示例 &lt;input /&gt; 正确示例 &lt;input name=&quot;userName&quot;/&gt; //当这种状况下在用户输入的数据后（eg：Wz）数据才能以userName=Wz的形式传递给后台服务器 type属性 type=”radio”，单选按钮 此处容易混乱 eg：如何设置才能保证单选？eg：性别一个表示男要给表示女 //正确设置示例： 男&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;/&gt; 女&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female:/&gt; //错误示例 男&lt;input type=&quot;radio&quot; name=&quot;male&quot;/&gt; 女&lt;input type=&quot;radio&quot; name=&quot;female&quot;/&gt; //错误示例 男&lt;input type=&quot;radio&quot; name=&quot;gender&quot;/&gt; 女&lt;input type=&quot;radio&quot; name=&quot;gender&quot;/&gt; 此单选标签在使用的使用一定要写三个属性：type、name、value type：放置radio属性 name：服务器可以识别，因为是单选按钮所以要设置一样的name属性 value：用于提交给服务器的值 type=”hidden”, 隐藏域 应用场景即为某条数据不需要给用户展示，但是用户需要用到这条数据作为逻辑处理 * 场景一: 需要从前台传递一个方法的名称到后台以便调用对应的方法； * 场景二：需要从前台传递一个商品的id值到后台以便后台根据此商品id查询出有关该商品的详细信息。 select下拉列表标签 写法： 12345&lt;select name=&quot;city&quot; type=&quot;multiple&quot;&gt; &lt;option value=&quot;0&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;南京&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;苏州&lt;/option&gt;&lt;/select&gt; name属性：发送给服务器的名称 multiple属性：不屑默认单选，取值为multiple表示多选 子标签：下拉列表中的一个选项（一个item） selected：勾选当前列表项 value：发送给服务器的选项值 textarea文本域标签 &lt;textarea&gt;文本域。多行的文本输入控件 col属性：文本域的列数 rows属性：文本域的行数 注意：给文本域标签设置默认值的方式：&lt;textarea name=&quot;beizhu&quot;&gt;hello&lt;/textarea&gt; hello即为默认值。 div标签 写法：&lt;div&gt;&lt;/div&gt; div标签就是HTML一个普通标签，进行区域划分 特性：独占一行。 通常用id或class来标签div标签，再结合CSS样式渲染来实现各种效果。 表格标签★★★★★ table：是父标签，相当于整个表格的容器 border：表格边框的宽度 width：表格的宽度 cellpadding：单元边沿与其内容之间的空白 cellspacing：单元格之间的空白 bgcolor：表格的背景颜色 tr标签：用于定义行td标签：用于定义表格的单元格（一个列）colspan：单元格可横跨的列数rowspan：单元格可横跨的行数align：单元格内容的水平对齐方式，取值：left 左、right 右、center 居中。nowrap：单元格中的内容是否折行 超链接标签a标签★★★★★ &lt;a&gt;标签是超链接标签，是在HTML页面提供的一种可以访问其他位置的实现方式。href：用于确定需要显示页面的路径（URL）target：确定以何种方式打开href所设置的页面。常用取值:_blank、_self等 * _blank： 在新窗口中打开href确定的页面。 * _self默认：使用href确定的页面替换当前页面。 CSS核心知识点CSS样式规则 具体格式 12345 选择器&#123;属性1:属性2;属性2:属性值;...&#125; 具体示例 123456&lt;style&gt; h2&#123; color:red; font-size:100px; &#125;&lt;/style&gt; 注意事项 CSS样式”选择器”严格区分大小写，”属性”和”属性值”不区分大小写 多个属性之间必须使用应为状态下的分号隔开，最后一个属性后的分号可以省略。但是为了增加新样式最好保留。 如果属性之间的值由多个单词组成且中间包含空格，则必须为这个属性值加上英文状态下的引号。引入CSS样式 ★★★ 行内样式 style1234567891011121314151617181920 * 通过标签内部style属性来设置元素的样式 * 行内样式通过标签的属性来控制样式，这样并没有做到结构与标签（HTML展示结构、CSS显示效果）相互分离，所以一般很少使用。* 内部样式 &lt;style type=&quot;text/css&quot;&gt; body&#123; background-color:#ddd; &#125; &lt;/style&gt; * 内嵌式CSS样式只对其所在的HTML页面有效，对其他页面无效，因此不能充分发挥CSS代码的重用优势。* 外部样式 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/demo00.css&quot;/&gt;### 选择器* 元素选择器 * 即用标签名如a、div、table、h1等做选择器 h1{ color:#F00; font-size:50px; } 12* 类选择器 * 给标签设置class后用.class的方式选择标签 .myClass{ font-size:25px; } Java ` 转换：Display HTML提供丰富的标签，这些标签被定义成不同的类型一般分为：块标签和行内标签 块标签：以区域块方式出现。每个块标签独自占据一整行或多整行 常见的块元素：&lt;h1&gt;、&lt;div&gt;、&lt;ul&gt;等 行内元素：不必在新的一行开始，同时也不强迫其他元素在新的一行显示。 常见的行内元素: &lt;span&gt;、&lt;a&gt;等 常见属性值: inline: 此元素将显示为行内元素（行内元素默认的display属性值）。 block：此元素将显示块元素（块元素默认的display属性值）。 none：此元素将被隐藏，不显示，也不占用页面空间。]]></content>
      <categories>
        <category>JavaWebCoreNote</category>
      </categories>
      <tags>
        <tag>JavaWebCoreNote</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWebCoreNote]]></title>
    <url>%2F2018%2F12%2F16%2FJavaWebCoreNote%2F</url>
    <content type="text"><![CDATA[JavaWebCoreNot系列的内容来源于GitHub上的知识，感谢GitHub用户名为ZhangxiaoHuangfu的分享！ Introduce 适用于初学者使用 JavaWeb核心阶段的主要内容：HTML、CSS、JS、jQuery、Bootstrap、MySQL、JDBC、dbuitls、xml、反射、http、tomcat、Servlet、response、request、Cookie、Session、JSP、EL、JSTL、Ajax、监听器Listener、过滤器Filter、Linux、Redis 目录(Contents)`01. HTML和CSS核心知识点汇总 JavaScript和jQuery核心知识点汇总 MySQL核心知识点汇总 JDBC核心知识点汇总 XML核心知识点汇总 反射核心知识点汇总 HTTP协议核心知识点汇总 Servlet核心知识点 Tomcat核心知识点汇总 Response核心知识点汇总 Request核心知识点汇总 Cookie核心知识点汇总 Session核心知识点汇总`]]></content>
      <categories>
        <category>JavaWebCoreNote</category>
      </categories>
      <tags>
        <tag>JavaWebCoreNote</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window常用命令]]></title>
    <url>%2F2018%2F12%2F16%2Fwindow%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用命令 keyword function D/E: 进入D/E盘 ipconfig 查看本机IP cls 清除屏幕 appwiz.cpl 打开删除程序面板 msinfo32 系统信息 win + shift + s 截屏 12345//删除占用指定端口的进程netstat -ano|findstr &quot;8080&quot; //查询8080端口taskkill/pid 3017 /F 关闭pid为3017的进程 /F标识强制结束 cmd控制台输入命令 keyword description IPCONFIG 进入DOS命令一打直接显示当前的所有网络配置 NETSTAT 显示当前网络链接状态 PING 192.168.0.1 判断DNS解析是否正常 arp 查看主机存储的IP和MAC的映射 systeminfo 查看系统信息（带图像界面的输入msinfo32 tasklist 当前进程列表 各种应用程序直接通过win+r中运行 keyword descrption service.msc 打开服务 devmgmt.msc 打开设备管理 control 打开控制面板 regedit 打开注册表 appwiz.cpl 打开删除程序的面板 msinfo32 系统信息 windows中各种快捷键 keyword function win + E 打开文件管理器 win + D 显示桌面 win + L 锁定计算机 alt + F4 关闭当前程序]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows window常用cmd命令 windows小知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我所走过的坑]]></title>
    <url>%2F2018%2F12%2F16%2F%E6%88%91%E6%89%80%E8%B5%B0%E8%BF%87%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"></content>
      <tags>
        <tag>遇到过的🕳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络基础]]></title>
    <url>%2F2018%2F12%2F16%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[计算机网络发展史 数据通信术语 数据传输 数据的编码和调制 数据交换技术 传输介质 计算机网络发展史 计算机网络的发展：雏形 ——&gt; 形成 ——&gt; 成熟（标准化）——&gt; 发展 四大阶段 1.计算机网络的”雏形”阶段 —— 面向终端的计算机网络 1946 宾夕法尼亚大学 第一台计算机ENIAC 2.计算机网路的”形成”阶段 ——- 计算机与计算机的直接通信 20世纪60年代末，美国国防部研究DAPA建成了ARPANET。只有四台主机相连接为了提供系统性能，让计算机和线路之间设置通信控制处理机（Communication Control Processor CCP) 通信设备和计算机、终端等都成为结点（交换节点）和（访问节点）。 通信设备——&gt; 交换节点 支持网络的连接并提交转发与交换功能。 计算机、终端—–&gt; 访问节点 3.计算机网络的”标准化”阶段 ———– 网络体系结构的标准化统一 ISO为International Standardization Organization（国际标准化组织） OSI为Open System Interconnnection（开发系统互连） 4.计算机网络的“发展”阶段 ——- 计算机网络互联与高速阶段 20世纪80年代最终选用了在1974年（文顿*瑟夫）和卡尔提出的TCP/IP协议 数据通信术语 1.数据 数据是指尚未定义的各种数字、字符、符号等的集合，可以是数值、文字、图形、声音、动画、图像、数据本身没有实际意义。2.信息信息（Information）是指经过加工处理后得到的具有一定意义的数据，是对人们有用的数据。（数据是信息的表示形式，信息是数据的内涵形式。） 3.信号 信号（Signal)是数据在传输过程中的物理表现形式。eg：光信号、电信号等，在通信系统中，这些物理信号可以是模拟信号或数字信号 模拟信号随时间变化的模拟信号，eg：语音信号、电视的视频信号等。数字信号随时间离散变化的信号是数字信号，eg：二进制数字0和1.4.信道信道（Channel）是传输信号的通道，即通信线路，包括通信设备和传输介质 信道分类 分类方法 分类结果 传输介质 有线信道（有线传输介质的信道）无线信道（使用无限传输介质的信道 使用方式 专用信道(用户设备之间的固定电路) 公共信道（通过交换机转接的信道） 传输信号的类型 模型信道（传输模型信号的信道) 数字信道（传输数字信号的信道） 5.数据通信系统 模拟通信系统 【信源】 ——&gt; 【调制器】 —–[信道] —–&gt; 【解调器】—–&gt; 【信宿】 数字通信系统 【信源】 ——&gt; 【信源编码器】——&gt; 【信道编码器】——&gt;【调制器】 —[信道]—&gt; 【解调器】 ——&gt; 【信道译码器】 ——&gt;【信源译码器】 ——&gt; 【新宿】 数据通信的主要技术指标 1) 数据传输速率 数据传输速率（比特率）：单位时间内传输的二进制位数（bit/s)比特率：Kb/s、Mb/s、Gb/s表示。1Kb/s = 10的3次方b/s 2) 信号传输速率 信号传输速率（波特率）：单位时间内传输的信号（码元）的个人（波特（baud））【比特率 = 波特率 * log2N(b/s)】 3) 信道容量 信道容量表示信道所能承受的最大数据传输速率，即单位时间内传输的最大二进制位数或最大码元数，单位（b/s）和波特（paud）信道容量是衡量信道传输能力的指标4）信道带宽信道带宽是表示信号频带范围，即信道所能传输信号频率的最大值和最小值之差，单位赫兹（Hz）。 信道容量受到带宽的限制。 6.数据传输1. 通信线路的连接方式: 点到点连接和多点线路连接两种 1) 点到点连接:在发送段和接收端之间采用一条线路连接。 2）多点连接：线路共享可以采用频分多路复用（线路在空间上共享，所有站点可同时发送数据）或时分多路复用（线路在时间上共享，所有站点都能轮流发送数据） 2. 数据传输类型 在信道上同时传输的数据位数： 1. 串行传输串行传输指数据以串行方式在一条信道上传输，即同时只能传输一个比特位。 计算机内部采用并行通信，因此在数据发送前要将计算机中的字符进行并/串转换，在接收端再进行串/并转换成计算机能识别的字符结构。 2. 并行传输并行通信是指数据以并行方式在多条信道上同时传输，如一次传输8位，并行通信速度快、效率高、适合近距离对速度要求较高的通信。 3. 基带传输基带传输是指在信道中直接传输数字信号。传输介质的整个带宽都被基带信号占用（基带传输系统安装简单、成本低，主要用于总线型拓跋结构的局域网） 4. 频带传输频带传输是指将数字信号调制成模拟信号后再发送，到接收端再把模拟信号解调位原来的数字信号。前提是收发双方都安装调制器和解调器。（可解决远距离传输的问题，可以实现多路复用，提高信道利用率） 宽带传输和频带传输区别? 宽带：比音频（4kHz)带宽更宽的频带，采用75Ω的同轴电缆或光纤作为传输介质。使用时将整个宽带划分为若干个子频带，分别用这些子频带来传输视频信号、音频信号和数字信号等。 数据传输的同步方式 数据传输的关键是实现收发双方之间的同步技术。通常使用的同步技术有两种：同步方式和异步方式。1）同步方式同步传输方式是以数据块（帧）为传输单位。同步字符和同步字节的引导。2）异步方式异步传输方式是以字符为传输单位。每传输一个字符都要再每个字符的二进制编码前加一个七十位表示字符的开始；在校验位后再加一个或两个停止位表示字符结束。接收方通过起始位和停止位来判断一个新字符的开始和结束。实现收发双方通古比。 信道复用技术：复用技术指在一个通信线路同时传输多个信号的技术。多路复用经过复合、传输和分离三个过程。 常见的多路复用技术有4种：频时波码 频分多路复用技术 时分多路复用技术 波分多路复用技术 码分多路复用技术 信道的通信方法信道的通信方式按照信号传输方向与时间的关系，可分为单工通信、双工通信和全双工通信三种 单工通信（发送端——————————————————&gt; 接收端） 单工通信是指信号只能沿着一个方向传输，发送端只能发送，接收端只能接收。eg：电视、无线电广播 半双工通信 半双工通信是指信号可以沿着两个方向传输，但不能同时双方相互交互要通过开关装置切换。eg(对讲机、步话机) 全双工通信 全双工方式是指信号同时可以沿着两个相反方向传输，通信的双方可同时发送与接收信号。（eg：电话） 数据的编码和调制 数据的编码方式包括数字数据的编码和调制以及模拟数据的编码与调制，数据在传输的过程中的编码类型却决于它采用的信道所支持的数据类型。 数字数据的编码 不归零编码（Non-Return to Zero）用负电平表示逻辑1，用正电平表示逻辑0，收发双方不能同步 曼彻斯特编码（Manchester）每一位二进制信号的中间都有跳变，在高低电平之间来回跳转。 差分曼彻斯特编码（Difference Manchester）的原理是每位二进制数据以开始边界是否发生跳变来决定取值 模拟数据的调制将模式数据转换成模拟信号的主要作用是使其可以长距离传输。模拟数据的基本调制技术主要：调幅AM、调频FM和调相PM。模拟数据的调制技术主要用于广播、电话系统。 模拟数据的编码采样 —&gt; 量化 —&gt; 编码 数据交换技术交换技术： 按原理： 1.电路交换和2.存储转发交换按存储转发交换根据转发的信息单位不同1.报文交换和2.分组交换 传输介质 传输介质是网络中发送和接收双方之间的通信的物理通道。 有线传输介质 双绞线（Twsited Pair，TP） 同轴电缆（Coaxial Cable） 光纤（Optical Fiber） 无线传输介质 微波 卫星 激光 红外线 网卡地址和IP地址 网卡地址（MAC地址或物理地址），由48位二进制数表示。前24位生产厂商后24位生产厂商所分配的网卡序号。（唯一） IP地址又是逻辑地址，唯一标识网络中主机（设备）的位置。IPv4用32位二进制表示一个IP地址。IP地址4个字节，每个字节8位。 192.168.1.1032位的IP地址包括3个部分：地址类别、网络号和主机号IP地址有A（0）、B（10）、C（110）、D（1110）、E(11110)之分 A、B、C类可分配地址 D类用于组播 E类用于实验]]></content>
      <categories>
        <category>计算机网络基础</category>
      </categories>
      <tags>
        <tag>计算机网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2018%2F12%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode study notes]]></title>
    <url>%2F2018%2F12%2F16%2FLeetcode-study-notes%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[schedule]]></title>
    <url>%2F2018%2F12%2F15%2Fschedule%2F</url>
    <content type="text"><![CDATA[1. HeadFirst系列丛书2. 阿里巴巴技术手册（码出高效）3. Mysql数据库4. 软件开发5. 英语]]></content>
      <categories>
        <category>小目标</category>
      </categories>
      <tags>
        <tag>schedule</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The usage of the Hexo]]></title>
    <url>%2F2018%2F12%2F15%2FThe-usage-of-the-Hexo%2F</url>
    <content type="text"><![CDATA[Hexo的基本使用 hexo g = hexo generate // 生成hexo d = hexo deploy // 部署hexo s = hexo server // 运行服务器hexo new post “article title” //新建文章 Hexo撰写文章创建文章 在站点（eg：F:Blog就是 XXX MINGW64 /F/Blog）下使用此命令：hexo new “title” 此时就会在Blog/source/_post文件夹中创建一个名为: title.md,而这个文件就是要发布到网站上的原始文件，记录文章内容。 使用Markdown编写文章 部署发布 hexo g -d建议：在使用命令 hexo g 部署之后，可以先使用 hexo s 运行本地站点，在浏览器输入地址http://lacolhost:4000/查看运行结果，检查没有错误后再使用命令 hexo d 发布 Hexo命令 init 在folder中建立一个网站 hexo init [folder]public 生成的网站文件，发布的站点文件。 source资源文件夹，用于存放内容。 tag 标签文件夹。 archive归档文件夹。 category分类文件夹。 downloads/code include code文件夹。 :lang i18n_dir 国际化文件夹。 _config.yml 配置文件 new 新建一篇文章。默认为layout布局如果标题含有空格，使用引号括起来 hexo new [layout] generate 生成静态文件(-d, –deploy文件生成后立即部署网站) hexo generate publish 发表草稿 hexo publish [layout] server 启动服务器，默认情况下，访问网址为:localhost:4000/ hexo server deploy 部署网站 （一般写文章的时候：hexo g -d 这种形式使用较多） hexo deploy render 渲染文件 hexo render [f1]… migrate 从其他博客系统迁移内容 hexo migrate clean 清除缓存文件(db.json)和已经生成的静态文件(public)在某些情况下（尤其是在更换主题之后），如果发现对站点的更改不生效可以使用此命令 hexo clean list 列出网站资料 hexo list version 显示Hexo版本 hexo version 选项安全模式 hexo –safe 在安全模式下，不会载入任何插件和脚本，当安装新插件遇到问题时，可以尝试以安全模式重新执行。 调试模式 hexo –debug 在终端中显示调试信息并记录到debug.log]]></content>
  </entry>
  <entry>
    <title><![CDATA[英语单词]]></title>
    <url>%2F2018%2F12%2F15%2F%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[单词 短语 例句 prosperity n.繁荣昌盛 thriving and prosperous Wish prosperity your new company drain v.排水n.下水道，消耗 brain drain These drains are used to carry sewage away filthya.污秽的;肮脏的 filthy lucre 不义之财 None of the roommates liked to clean,so the place was always filthy tenuren.任期，终身职位 CEO tenure The queen’s tenure has broken the record desolatea.荒凉的；孤单寂寞的 desolate wilderness荒凉的原野 The place has become very desolate now. physiologicala.生理的，生理学的 pyhsicological need生理需要 The teacher is giving a lecture about physicological knowledge reproachv.责备、指责 beyond reproach They reproached him for being late to the meeting lobstern.龙虾v.捕龙虾 baked lobster Lobster is a delicious kind of seafood guidancen.引导、指导 Guidance Note指引摘要 The man gives some guidance to the boy about how to play the violin preferencen.偏爱；喜爱物 trade preference贸易优先权 I have a preference for fruits over sweets比起糖，我偏爱水果 2018/12/15 单词 短语 例句 Python n.蟒蛇、巨蛇 Python Programming Tutorial My giant python snake is the greatest pet ever! demography人口统计学 school demography学校普查 Demography is the study of the statistics of human populations人口统计学使研究人口的统计规律的学科 convulsev.使震动、使抽出 convulse nation The patient convulsed before losing consciousness. attestvt.证明;作证n.证明书 Hygiene attest卫生证明 Let me give you a note to take to school to attest that you are ill. stubblen.残株；发茬;胡茬 corn stubble玉米胡茬 I haven’t shaved for a few days;it’s grown some stubble. incipient初期的，刚出现的 incipient cataract初期白内障 Buds are the incipient stage of flowers.花蕾使一朵化最初期的样子 querulousa.易怒的，暴躁的，抱怨的 querulous comments不满的声音 My querulous old dad’s always complaining about something or other. redemptionn.赎回;实践;偿还 Redemption Point换购积分 A confession is the only way to get redemption忏悔使获得拯救的唯一方式 legiblea.清晰的;易读的 Legible diagram清晰的图标 It’s clear to see the typewritten note is more legible很显然，电脑打印的便条他更清晰易读 irreparable不能修复的；不可弥补的 irreparable system不可修复的系统 The cellphone was broken so badly that it is irreparable.这部手机被砸的太烂，已经不能修补了 2018/12/16 单词 短语 例句 dissolute a.放荡、无节制的 dissolute habit My mother has a dissolute lifestyle;she’s drunk all the time confidant n.密友 female confidant 红颜知己 Every girl needs a confidant excise v.收税、切除、删去n.货物税 excise system demote v.降级、降职 demote sb The boy was demoted from the rank of captain to group leader. coercion n.强制、胁迫、威压 capitalized coercion When I was a kid mom always had to use coercion to get me to do my chores registrar n.登记员、记录员 Registrar Server You have to fill in a form at the registrar’s if you want to vote. disinterested a.无私的、公正的、冷漠的、廉洁的 disinterested advice 客观的建议 The judge maintained a disinterested attitude, favoring neither the plaintiff(原告) nor the defendant（被告） defrost v.除霜、解冻 Automatic defrost 自动除霜 I need to defrost the windshield(给窗户除霜) so I can see where I’m going. emulate v.努力赶上（超过）、仿效 system emulate 系统仿真 My daughter likes to emulate my yoga poses. foreground n.前景、最显著的位置v.强调 foreground task 前台任务 A woman is doing Yoga in the foreground,while the sun rises in the background 2018/12/17 单词 短语 例句 potent a.强有力的、有权势的、有说服力的 Potent Challenge强势冲击 His arms are very potent; he can lift things I could never dream of lifting. paramount n元首a至上，首要的 paramount clause首要条款 It‘s paramount that we make the VIP happy 我们首要的任务就是让贵宾开心！ perpetrator n.作恶者、犯罪者、行凶者 perpetrator detail 行凶者 I’ve been burgled- I wonder what kind of persson the perpetrator is ? predicament n.困境、尴尬的处境 economic predicament 经济困境 I’m in a predicament and don’t know where to go since here are so many traps beastly a.野蛮的、残忍的、可恶的 beastly weather 恶劣的天气 How could you be so beastly to eat this cute rabbit! contend v.竞争；争论、主张 contend superiority 竞争优势 The two fighters contend for the championship两个斗士在为争夺冠军而搏斗 mainstream n.主流，主要倾向v。使…成为主流 mainstream cultrue 主流文化 Most people tend to go with the mainstream opinion adversary n.对手、敌手 fantastic adversary 不可思议的对手 At arm wrestling,she’s a surprisingly tough adversary 在扳手中，她是意想不到的强敌 plank n.厚木板、政纲条款、要点 plank bridge 木板桥 Wooden planks are often used to build doors. fiasco n.大失败、惨败 Football Fiasco What a fiasco-dating my boss really wasn’t a good idea!这真是个大失败，和老板约会真心不是好主意！ 2018/12/18]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语单词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javaweb]]></title>
    <url>%2F2018%2F12%2F14%2FJavaweb%2F</url>
    <content type="text"><![CDATA[Servlet上下文 Servlet容器在启动时会自动加载Web应用，并未每个Web应用创建唯一的ServletContext对象，在ServletContext接口中定义了一组方法，Servlet可以使用这些方法与Servlet容器进行通信。 eg： 存放共享数据、得到文件的MIME类型、转发请求、向日志文件写入消息等。 ServletContext接口 一个ServletContext对象代表一个Web应用程序的上下文。Servlet容器在Servlet初始化期间向其传递要给ServletConfig对象，可以通过这个对象的getServletContext()方法来得到ServletContext对象，也可以通过GenericServlet类的getServletContext()方法来得到它。 ServletContext中常用的方法|方法名|描述||—:|—:||getAttribute()|根据给定的属性返回设定的值||getAttributeName()|返回一个Enumeration对象，它包含了存储在ServletContext对象中的所有属性名||getAttribute(String name,Object object)|把一个对象和一个属性名绑定，将对象存储在这个ServletContext| 使用ServletContext实现计算网页访问的次数123456789ServletContext context = getServletContext();Integer count = (Integer)context.getAttribute(&quot;counter&quot;);if(count == null)&#123; count = new Integer(1);&#125;else&#123; count = new Integer(count.intValue+1)&#125;context.setAttribute(&quot;counter&quot;,count); 请求转发与重定向 在Web应用中，MVC（模型-视图-控制器）。在MVC模式中控制器的角色由Servlet充当，它可以将请求转发给另一个Servlet或JSP页面，然后由他们进行处理并产生对i请求的响应。完成请求转发就要使用到javax.servletRequestDispatcher接口。 RequestDispatcher接口 RequestDispatcher对象由Servlet容器创建。用于封装一个由路径所表示的服务器资源。利用RequestDispatcher对象，可以把请求转发给其他的Servlet或JSP页面。在RequestDispatcher接口中定义的两个方法： (1) forward(ServletRequest request,ServletResponse response) 该方法用于将请求从另一个Servlet传递给服务器上的其他Servlet、JSP或者是HTML页面。在Servlet中，可以对请求进行处理，然后调用这个方法，由其他的资源来生成响应 获取RequestDispatcher对象 有三种方法可以得到RequestDispatcher对象： 一种是利用ServletRequest接口中的getRequestDispatcher()方法， 利用ServletContext接口中的getNamedDispatcher() 利用ServletContext接口中的getRequestDispatcher() ServletRequest接口和ServletContext接口各自提供了一个getRequestDispatcher()方法，他们的参数都是资源的路径名。但是ServlertContext.getRequestDispatcher()方法的参数必须以（/）开始，被解释为相对于当前上下文根路径ServletRequest.getRequestDispatcher()方法的参数不但可以是相对于上下文根的路径，还可以是相对于当前Servlet的路径。 ####### 请求重定向 HttpServletResponse接口的sendRedirect()方法和RequestDispatcher接口的forward()方法都可以利用其他的资源（Servlet、JSP或HTML文件）来为客户服务，但两种方法有本质的区别 会话跟踪 当客户访问Web应用时，Web服务器经常需要跟踪用户的状态Web服务器跟踪客户状态的方法4种： 建立含有跟踪数据的隐藏表单字段 重写包含额外参数的URL 使用持久化的Cookie 使用ServletAPI中的Session（会话）机制]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
