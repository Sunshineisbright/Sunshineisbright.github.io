<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[schedule]]></title>
    <url>%2F2018%2F12%2F15%2Fschedule%2F</url>
    <content type="text"><![CDATA[1. HeadFirst系列丛书2. 阿里巴巴技术手册（码出高效）3. Mysql数据库4. 软件开发5. 英语]]></content>
      <categories>
        <category>小目标</category>
      </categories>
      <tags>
        <tag>schedule</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The usage of the Hexo]]></title>
    <url>%2F2018%2F12%2F15%2FThe-usage-of-the-Hexo%2F</url>
    <content type="text"><![CDATA[Hexo的基本使用 hexo g = hexo generate // 生成hexo d = hexo deploy // 部署hexo s = hexo server // 运行服务器hexo new post “article title” //新建文章 Hexo撰写文章创建文章 在站点（eg：F:Blog就是 XXX MINGW64 /F/Blog）下使用此命令：hexo new “title” 此时就会在Blog/source/_post文件夹中创建一个名为: title.md,而这个文件就是要发布到网站上的原始文件，记录文章内容。 使用Markdown编写文章 部署发布 hexo g -d建议：在使用命令 hexo g 部署之后，可以先使用 hexo s 运行本地站点，在浏览器输入地址http://lacolhost:4000/查看运行结果，检查没有错误后再使用命令 hexo d 发布 Hexo命令 init 在folder中建立一个网站 hexo init [folder]public 生成的网站文件，发布的站点文件。 source资源文件夹，用于存放内容。 tag 标签文件夹。 archive归档文件夹。 category分类文件夹。 downloads/code include code文件夹。 :lang i18n_dir 国际化文件夹。 _config.yml 配置文件 new 新建一篇文章。默认为layout布局如果标题含有空格，使用引号括起来 hexo new [layout] generate 生成静态文件(-d, –deploy文件生成后立即部署网站) hexo generate publish 发表草稿 hexo publish [layout] server 启动服务器，默认情况下，访问网址为:localhost:4000/ hexo server deploy 部署网站 （一般写文章的时候：hexo g -d 这种形式使用较多） hexo deploy render 渲染文件 hexo render [f1]… migrate 从其他博客系统迁移内容 hexo migrate clean 清除缓存文件(db.json)和已经生成的静态文件(public)在某些情况下（尤其是在更换主题之后），如果发现对站点的更改不生效可以使用此命令 hexo clean list 列出网站资料 hexo list version 显示Hexo版本 hexo version 选项安全模式 hexo –safe 在安全模式下，不会载入任何插件和脚本，当安装新插件遇到问题时，可以尝试以安全模式重新执行。 调试模式 hexo –debug 在终端中显示调试信息并记录到debug.log]]></content>
  </entry>
  <entry>
    <title><![CDATA[英语单词]]></title>
    <url>%2F2018%2F12%2F15%2F%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[单词 短语 例句 prosperity n.繁荣昌盛 thriving and prosperous Wish prosperity your new company drain v.排水n.下水道，消耗 brain drain These drains are used to carry sewage away filthya.污秽的;肮脏的 filthy lucre 不义之财 None of the roommates liked to clean,so the place was always filthy tenuren.任期，终身职位 CEO tenure The queen’s tenure has broken the record desolatea.荒凉的；孤单寂寞的 desolate wilderness荒凉的原野 The place has become very desolate now. physiologicala.生理的，生理学的 pyhsicological need生理需要 The teacher is giving a lecture about physicological knowledge reproachv.责备、指责 beyond reproach They reproached him for being late to the meeting lobstern.龙虾v.捕龙虾 baked lobster Lobster is a delicious kind of seafood guidancen.引导、指导 Guidance Note指引摘要 The man gives some guidance to the boy about how to play the violin preferencen.偏爱；喜爱物 trade preference贸易优先权 I have a preference for fruits over sweets比起糖，我偏爱水果]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语单词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javaweb]]></title>
    <url>%2F2018%2F12%2F14%2FJavaweb%2F</url>
    <content type="text"><![CDATA[Servlet上下文 Servlet容器在启动时会自动加载Web应用，并未每个Web应用创建唯一的ServletContext对象，在ServletContext接口中定义了一组方法，Servlet可以使用这些方法与Servlet容器进行通信。 eg： 存放共享数据、得到文件的MIME类型、转发请求、向日志文件写入消息等。 ServletContext接口 一个ServletContext对象代表一个Web应用程序的上下文。Servlet容器在Servlet初始化期间向其传递要给ServletConfig对象，可以通过这个对象的getServletContext()方法来得到ServletContext对象，也可以通过GenericServlet类的getServletContext()方法来得到它。 ServletContext中常用的方法|方法名|描述||—:|—:||getAttribute()|根据给定的属性返回设定的值||getAttributeName()|返回一个Enumeration对象，它包含了存储在ServletContext对象中的所有属性名||getAttribute(String name,Object object)|把一个对象和一个属性名绑定，将对象存储在这个ServletContext| 使用ServletContext实现计算网页访问的次数123456789ServletContext context = getServletContext();Integer count = (Integer)context.getAttribute(&quot;counter&quot;);if(count == null)&#123; count = new Integer(1);&#125;else&#123; count = new Integer(count.intValue+1)&#125;context.setAttribute(&quot;counter&quot;,count); 请求转发与重定向 在Web应用中，MVC（模型-视图-控制器）。在MVC模式中控制器的角色由Servlet充当，它可以将请求转发给另一个Servlet或JSP页面，然后由他们进行处理并产生对i请求的响应。完成请求转发就要使用到javax.servletRequestDispatcher接口。 RequestDispatcher接口 RequestDispatcher对象由Servlet容器创建。用于封装一个由路径所表示的服务器资源。利用RequestDispatcher对象，可以把请求转发给其他的Servlet或JSP页面。在RequestDispatcher接口中定义的两个方法： (1) forward(ServletRequest request,ServletResponse response) 该方法用于将请求从另一个Servlet传递给服务器上的其他Servlet、JSP或者是HTML页面。在Servlet中，可以对请求进行处理，然后调用这个方法，由其他的资源来生成响应 获取RequestDispatcher对象 有三种方法可以得到RequestDispatcher对象： 一种是利用ServletRequest接口中的getRequestDispatcher()方法， 利用ServletContext接口中的getNamedDispatcher() 利用ServletContext接口中的getRequestDispatcher() ServletRequest接口和ServletContext接口各自提供了一个getRequestDispatcher()方法，他们的参数都是资源的路径名。但是ServlertContext.getRequestDispatcher()方法的参数必须以（/）开始，被解释为相对于当前上下文根路径ServletRequest.getRequestDispatcher()方法的参数不但可以是相对于上下文根的路径，还可以是相对于当前Servlet的路径。 ####### 请求重定向 HttpServletResponse接口的sendRedirect()方法和RequestDispatcher接口的forward()方法都可以利用其他的资源（Servlet、JSP或HTML文件）来为客户服务，但两种方法有本质的区别 会话跟踪 当客户访问Web应用时，Web服务器经常需要跟踪用户的状态Web服务器跟踪客户状态的方法4种： 建立含有跟踪数据的隐藏表单字段 重写包含额外参数的URL 使用持久化的Cookie 使用ServletAPI中的Session（会话）机制]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Javaweb</tag>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
